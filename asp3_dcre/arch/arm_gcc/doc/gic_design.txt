
		TOPPERS/ASP3カーネル
		GIC（ARM Generic Interrupt Controller）依存部 設計メモ

		対応バージョン: Release 3.7.1
		最終更新: 2022年5月29日

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2014-2022 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: gic_design.txt 1809 2023-04-11 07:45:05Z ertl-hiro $
----------------------------------------------------------------------

○目次

・参考文献
・GIC依存部の位置づけ
	- GIC依存部を構成するファイル
・チップ依存のパラメータ
	- アプリケーションから参照できるパラメータ
	- カーネル内部で使用するパラメータ
・GICにおける割込みハンドラの出入口処理
	- 割込み要求のクリア
	- 割込み優先度マスクの操作
・GICにおけるCPU例外ハンドラの出入口処理

○参考文献

[1] TOPPERSプロジェクト 設計メモ「GIC（ARM Generic Interrupt
Controller）に関するメモ」．

○GIC依存部の位置づけ

GIC依存部は，カーネルのターゲット依存部の中で，GICアーキテクチャGICv1
およびGICv2に準拠した割込みコントローラを持つチップに共通に使用できる
部分である．また，GICの前身と思われるARM11 MPCoreのDistributed
Interrupt Controllerにも適用できるように実装する．

TOPPERS_SAFEG_SECUREがマクロ定義されている場合には，GICがセキュリティ拡
張されていることを想定し，セキュアモードで使用するものとする．

GICv1とGICv2でレジスタ名が変更になっているが，ソースコード中では，
GICv2のレジスタ名を使用する．

●GIC依存部を構成するファイル

GIC依存部は，次の3つのファイルで構成される．

  arch/arm_gcc/common/
	gic_kernel_impl.h	カーネルの割込みGIC依存部のヘッダファイル
	gic_kernel_impl.c	カーネルの割込みGIC依存部
	gic_support.S		カーネルの割込みGIC依存部のアセンブリ言語部

○チップ依存のパラメータ

●アプリケーションから参照できるパラメータ

target_kernel.h（または，そこからインクルードされるファイル）で，以下の
定数をマクロ定義しておく．

(1) TMIN_INTPRI			割込み優先度の最小値（最高値）
(2) TMAX_INTPRI			割込み優先度の最大値（最低値）

TMAX_INTPRIは，-1に定義する．TMAX_INTPRIは，ターゲットチップのGICでサポー
トする割込み優先度の段数により，-15，-31，-63，-127，-255のいずれかに定
義する．

●カーネル内部で使用するパラメータ

target_kernel_impl.h（または，そこからインクルードされるファイル）から
gic_kernel_impl.hをインクルードする前に，必要に応じて，以下の定数をマク
ロ定義しておく．

(1) GIC_TNUM_INTNO		割込みの数

ターゲットチップのGICがサポートする割込みの数．SGI（Software Generated
Interrupt），PPI（Private Peripheral Interrupt），SPI（Shared
Peripheral Interrupt）の合計数．

(2) GICC_BASE			CPUインタフェースのベースアドレス
(3) GICD_BASE			ディストリビュータのベースアドレス

GICのCPUインタフェースおよびディストリビュータのベースアドレス．

(4) TOPPERS_SAFEG_SECURE	セキュアモード（オプション）

セキュアモードでカーネルを動作させ，FIQをカーネル管理の割込みと扱う場合
に，このシンボルをマクロ定義する．

(5) GIC_ARM11MPCORE		ARM11 MPCoreへの対応（オプション）

ARM11 MPCoreのDistributed Interrupt Controllerの場合には，このシンボル
をマクロ定義する．

(6) GIC_SUPPORT_DISABLE_SGI		SGIの割込み要求禁止フラグが操作できる

GICの割込みイネーブルセット／クリアレジスタにより，SGI（Software
Generated Interrupt）の割込み要求禁止フラグがセット／クリアできる場合
に，このシンボルをマクロ定義する．なお，これができるかどうかは，GIC仕
様では実装定義となっており，Cortex-A9およびPL390ではできない仕様となっ
ている．

(7) OMIT_GIC_INITIALIZE_INTERRUPT	GICの標準の割込み初期化処理を使わない

GIC依存部の標準の割込み管理機能の初期化処理（initialize_interrupt）を
使わない場合には，このシンボルをマクロ定義する．

(8) GIC_PL390_ERRATA	GIC-390 Errataへの対策を実施する

GIC-390 Errataへの対策を実施する場合には，このシンボルをマクロ定義する．

○GICにおける割込みハンドラの出入口処理

irc_begin_intは，割込み優先度マスクを受け付けた割込み要求の割込み優先
度に設定し，割込みハンドラの入口で必要なIRCの操作を行う．irc_end_intは，
割込みハンドラの出口で必要なIRCの操作を行い，割込み優先度マスクを割込
み処理前の状態に戻す．

●割込み要求のクリア

GICでは，割込み要求ラインがエッジトリガである場合のトリガされた割込み
要求のクリアはハードウェアで行われるため，割込みハンドラの出入口処理で
行う必要はない．

●割込み優先度マスクの操作

GICにおける割込み優先度マスクの操作およびIRCに対する割込み処理の終了通
知（EOIの発行）の実現方法には，いくつかのアプローチがある．

なお，以下のコードは，スタックトップに保存用の領域が1ワード確保されて
いることを前提に記述している．また，irc_begin_intは，割込み番号をr4に
返すものとする．

【アプローチ1】

このアプローチは，GICの想定している（よって，最もシンプルな）ものである．
割込みハンドラの入口では何も行わず，割込みハンドラの出口でEOIを発行する．

----------------------------------------
ALABEL(irc_begin_int)
	/*
	 *  割込み要因を取得する．
	 */
	ldr		r1, =GICC_IAR
	ldr		r3, [r1]
	lsl		r4, r3, #22			/* 下位10ビットを取り出す */
	lsr		r4, r4, #22
	str		r3, [sp]			/* irc_end_intで用いる情報を保存 */

	/*
	 *  r4に割込み番号を入れた状態でリターンする．
	 */
	bx		lr

ALABEL(irc_end_int)
	/*
	 *  EOIを発行してリターンする．
	 */
	ldr		r3, [sp]			/* irc_begin_intで保存した情報を復帰 */
	ldr		r1, =GICC_EOIR		/* EOIレジスタへの書込み */
	str		r3, [r1]
	bx		lr
----------------------------------------

このアプローチには，次の問題点がある．

(1) 割込みハンドラからのリターン時に，割込み優先度マスクを元に戻すとい
う仕様を実装していると言えるか微妙である．

特に，CPU例外ハンドラをこれと整合するように実装した場合，CPU例外ハンド
ラの出入口で割込み優先度マスクを一切操作しないという実装になり，CPU例
外ハンドラからのリターン時に割込み優先度マスクを元に戻すという仕様に準
拠していないように思われる．この実装で良しとするには，割込み優先度マス
クを元に戻す処理の省略を許すように仕様変更する必要がある（統合仕様書の
チケット #605）。

(2) 割込み優先度が256段階ある時（この場合，ARM GICでは，割込み優先度の
すべてのビットをプリエンプションに使うという設定ができない）に，このア
プローチでは，割込み優先度のすべてのビットをプリエンプションに使うこと
ができず，TOPPERS標準割込み処理モデルからの逸脱となる．

ただし，256段階の割込み優先度が実装されていて，それをフルに使用する状
況は少ないと考えられるため，大きい問題ではないと考えられる．

(3) 割込みハンドラから割込み優先度マスクを参照する場合に，GICC_PMRと
GICC_RPRの両者の優先度が高い方を求める必要がある．

ASP3カーネルでは，割込みハンドラの実行中に割込み優先度マスクを参照／設
定することは，CPU例外ハンドラの入口で割込み優先度マスクを参照する処理
以外にはないため問題にならないが，ATK2カーネルではオーバヘッドが大きく
なるおそれがある．

以下では，これらの問題点を解決するアプローチについて説明する．

【アプローチ2】

問題点(1)を解決するためには，割込み優先度マスクを保存・復帰する必要が
ある．

----------------------------------------
ALABEL(irc_begin_int)
	/*
	 *  割込み要因を取得する．
	 */
	ldr		r1, =GICC_IAR
	ldr		r3, [r1]
	lsl		r4, r3, #22			/* 下位10ビットを取り出す */
	lsr		r4, r4, #22

	/*
	 *  割込み発生前の割込み優先度を保存する．
	 */
	ldr		r1, =GICC_PMR		/* 割込み発生前の割込み優先度を取得 */
	ldr		r2, [r1]
	push	{r2,r3}				/* irc_end_intで用いる情報を保存 */

	/*
	 *  r4に割込み番号を入れた状態でリターンする．
	 */
	bx		lr

ALABEL(irc_end_int)
	/*
	 *  EOIを発行する．
	 */
	pop		{r2,r3}				/* irc_begin_intで保存した情報を復帰 */
	ldr		r1, =GICC_EOIR		/* EOIレジスタへの書込み */
	str		r3, [r1]

	/*
	 *  割込み優先度マスクを元に戻してリターンする．
	 */
	ldr		r1, =GICC_PMR		/* 割込み優先度マスクを元に戻す */
	str		r2, [r1]
	bx		lr
----------------------------------------

割込み優先度マスクを保存するために，irc_end_intで用いるために保存する
情報が2ワードになり，スタック上の空き領域に収まらず，スタックの使用量
が増えている．

【アプローチ3】

問題点(3)を解決するためには，発生した割込み要因の割込み優先度を，割込
み優先度マスクに設定しておく方法が考えられる．割込み優先度マスクを設定
するために，割込み優先度マスクの保存・復帰が必要であり，問題点(1)も解
決される．

----------------------------------------
ALABEL(irc_begin_int)
	/*
	 *  割込み要因を取得する．
	 */
	ldr		r1, =GICC_IAR
	ldr		r3, [r1]
	lsl		r4, r3, #22			/* 下位10ビットを取り出す */
	lsr		r4, r4, #22

	/*
	 *  割込み要因の割込み優先度を求め，割込み優先度マスクに設定する．
	 */
	ldr		r1, =GICC_RPR		/* 受け付けた割込みの割込み優先度を取得 */
	ldr		r0, [r1]
	ldr		r1, =GICC_PMR		/* 割込み発生前の割込み優先度を取得 */
	ldr		r2, [r1]
	str		r0, [r1]			/* 新しい割込み優先度マスクをセットする */
	DATA_SYNC_BARRIER			/* 割込み優先度マスクがセットされるのを待つ */
	push	{r2,r3}				/* irc_end_intで用いる情報を保存 */

	/*
	 *  r4に割込み番号を入れた状態でリターンする．
	 */
	bx		lr

ALABEL(irc_end_int)
	/*
	 *  EOIを発行する．
	 */
	pop		{r2,r3}				/* irc_begin_intで保存した情報を復帰 */
	ldr		r1, =GICC_EOIR		/* EOIレジスタへの書込み */
	str		r3, [r1]

	/*
	 *  割込み優先度マスクを元に戻してリターンする．
	 */
	ldr		r1, =GICC_PMR		/* 割込み優先度マスクを元に戻す */
	str		r2, [r1]
	bx		lr
----------------------------------------

【アプローチ4】

問題点(2)を解決するためには，割込みハンドラの入口処理でEOIを発行してし
まう方法が考えられる．入口処理でEOIを発行するために，割込み優先度マス
クの保存・設定・復帰が必要であり，問題点(1)も解決される．また，問題点
(3)も解決される．

----------------------------------------
ALABEL(irc_begin_int)
	/*
	 *  割込み要因を取得する．
	 */
	ldr		r1, =GICC_IAR
	ldr		r3, [r1]
	lsl		r4, r3, #22			/* 下位10ビットを取り出す */
	lsr		r4, r4, #22

	/*
	 *  割込み要因の割込み優先度を求め，割込み優先度マスクに設定する．
	 */
	ldr		r1, =GICC_RPR		/* 受け付けた割込みの割込み優先度を取得 */
	ldr		r0, [r1]
	ldr		r1, =GICC_PMR		/* 割込み発生前の割込み優先度を取得 */
	ldr		r2, [r1]
	str		r0, [r1]			/* 新しい割込み優先度マスクをセットする */
	DATA_SYNC_BARRIER			/* 割込み優先度マスクがセットされるのを待つ */
	str		r2, [sp]			/* irc_end_intで用いる情報を保存 */

	/*
	 *  EOIを発行し，r4に割込み番号を入れた状態でリターンする．
	 */
	ldr		r1, =GICC_EOIR		/* EOIレジスタへの書込み */
	str		r3, [r1]
	bx		lr

ALABEL(irc_end_int)
	/*
	 *  割込み優先度マスクを元に戻してリターンする．
	 */
	ldr		r2, [sp]			/* irc_begin_intで保存した情報を復帰 */
	ldr		r1, =GICC_PMR		/* 割込み優先度マスクを元に戻す */
	str		r2, [r1]
	bx		lr
----------------------------------------

ただし，GICC_RPRは，実行中の割込みの「グループ優先度」を返すため，この
コードでは問題点(2)を解決できていない．問題点(2)を解決するには，受け付
けた割込みの割込み優先度を，割込み初期化ブロックに入れるなどの方法で管
理し，それをGICC_PMRに書き込むことが必要である．

このアプローチでは，割込みを受け付けると，即座に，同じ割込みを再受付け
可能になる．そのため，複数のプロセッサで実行できる割込みサービスルーチ
ンは，複数回の割込み要求により，異なるプロセッサで同時に実行される可能
性がある．統合仕様書 Release 3.5.0では，2.7.6節の使用上の注意でこの可
能性があることを記載しているが，それが望ましい振舞いであるかは疑問であ
る．そこで，統合仕様書 Release 3.6.0では，複数回の割込み要求があっても，
1つの割込みサービスルーチンが異なるプロセッサで同時に実行されることは
ないものと変更した．その結果，このアプローチは，統合仕様書 Release
3.6.0に合致しないことになった．

ASP3カーネルのRelease 3.6.0まではアプローチ4を採用していたが，上述の新
しい仕様に合致しなくなったため，Release 3.7.0ではアプローチ2に変更した．
そのため，問題点(2)と(3)は残っている．実際のコードでは，GIC-390 Errata
への対策を追加している．

○GICにおけるCPU例外ハンドラの出入口処理

GICにおけるCPU例外ハンドラの入口処理（irc_begin_exc）では，CPU例外発生
前の割込み優先度マスクをスタックに保存し，CPU例外ハンドラの入口処理
（irc_end_exc）で割込み優先度マスクを元に戻す．

----------------------------------------
ALABEL(irc_begin_exc)
	/*
	 *  割込み優先度マスクを保存する．
	 */
	ldr		r1, =GICC_PMR		/* 現在の割込み優先度を取得 */
	ldr		r2, [r1]
	str		r2, [sp]			/* irc_end_excで用いる情報を保存 */
	bx		lr
----------------------------------------
ALABEL(irc_end_exc)
	/*
	 *  割込み優先度マスクを元に戻す．
	 */
	ldr		r2, [sp]			/* irc_begin_excで保存した情報を復帰 */
	ldr		r1, =GICC_PMR		/* 割込み優先度マスクを元に戻す */
	str		r2, [r1]
	bx		lr
----------------------------------------

以上
