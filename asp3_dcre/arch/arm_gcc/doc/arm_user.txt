
		TOPPERS/ASP3カーネル
		ARM依存部 ユーザーズマニュアル

		対応バージョン: Release 3.7.1
		最終更新: 2023年4月11日

このドキュメントは，TOPPERS/ASP3カーネルのARM依存部を使用するために必要
な事項を説明するものである．

なお，ARM依存部を使用してターゲット依存部を実装する方法については，
「ターゲット依存部 ポーティングガイド（ARM向け）」を参照すること．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2014-2023 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: arm_user.txt 1809 2023-04-11 07:45:05Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．ARM依存部の概要
	1.1 ARM依存部のディレクトリ構成
	1.2 ARMコア依存部
	1.3 MPCore依存部
	1.4 GIC依存部
	1.5 RZ/A1チップ依存部
	1.6 その他の依存部
２．ターゲット定義事項の規定
	2.1 データ型に関する規定
	2.2 割込み処理に関する規定
		2.2.1 GIC依存部における割込み処理に関する規定
		2.2.2 RZ/A1チップ依存部における割込み処理に関する規定
	2.3 CPU例外処理に関する規定
	2.4 タイマに関する規定
		2.4.1 MPCoreチップ依存部
		2.4.2 RZ/A1チップ依存部におけるタイマに関する規定
	2.5 FPUサポートに関する規定
		2.5.1 FPUを常に使用する方法
		2.5.2 指定したタスクのみがFPUを使用する方法
	2.6 その他の規定・制約
	2.7 動的生成機能拡張に関する規定
３．使用上の注意とヒント
	3.1 MMUの設定
	3.2 CPU例外の原因の追及方法
	3.3 パフォーマンスモニタによる性能評価
	3.4 GIC-390 Errataへの対策
４．リファレンス
	4.1 ディレクトリ構成・ファイル構成
	4.2 バージョン履歴


１．ARM依存部の概要

ARM依存部は，TOPPERS/ASP3カーネルのターゲット依存部の中で，ARMv4，
ARMv5，ARMv6，ARMv7-A，ARMv7-R，ARMv8-AのAArch32，ARMv8-Rに準拠したプ
ロセッサコアを用いたターゲットシステムに共通に使用できる部分である．

1.1 ARM依存部のディレクトリ構成

ARM依存部の置かれているディレクトリは次の通り．

	arch/
		arm_gcc/common/			ARMコア依存部など
		arm_gcc/rza1/			RZ/A1チップ依存部
		arm_gcc/doc/			ARM依存部に関するドキュメント

1.2 ARMコア依存部

ARMコア依存部は，ARMv4，ARMv5，ARMv6，ARMv7-A，ARMv7-R，ARMv8-Aの
AArch32，ARMv8-Rに準拠したプロセッサコアを持つターゲットシステムに共通
に使用できる部分である．

コア略称等は次の通り．

	コア略称：arm
	開発環境略称：gcc

ARMコア依存部（GNU開発環境向け）は，arch/arm_gcc/commonに置かれている．

1.3 MPCore依存部

MPCore依存部は，ARM MPCoreアーキテクチャに基づいたプロセッサコアを持つ
ターゲットシステムに共通に使用できる部分である．MPCore依存部には，
MPCoreが持つタイマ（プライベートタイマ，ウォッチドッグ，グローバルタイ
マ）の操作や，SCU（スヌープ制御ユニット）の操作などが含まれる．MPCore
依存部（GNU開発環境向け）は，arch/arm_gcc/commonに置かれている．

MPCoreアーキテクチャはGICを含んでいることから，MPCore依存部を用いると，
GIC依存部も用いることになる．そのため，このドキュメント中でGIC依存部に
関して記述されたことは，MPCore依存部にも適用される．

1.4 GIC依存部

GIC依存部は，ARMの標準的な割込みコントローラの1つであるGIC（ARM
Generic Interrupt Controller）のバージョン2以前を用いたターゲットシス
テムに共通に使用できる部分である．現時点では，GICのバージョン3以降には
対応していない．GIC依存部（GNU開発環境向け）は，arch/arm_gcc/commonに
置かれている．

なお，一部のGICの実装には，GIC-390 Errataと呼ばれる不具合があることが
知られている．不具合があるチップを使用する場合には，「3.4 GIC-390
Errataへの対策」の節の記載事項に注意すること．

1.5 RZ/A1チップ依存部

RZ/A1チップ依存部は，ARM Cortex-A9コアを搭載したルネサス RZ/Aシリーズ
のチップを用いたターゲットシステムに共通に使用できる部分である．RZ/A1
チップ依存部には，RZ/Aシリーズのチップが持つOSタイマ（OSTM）の操作や，
FIFO内蔵シリアルコミュニケーションインタフェース（SCIF）の操作などが含
まれる．RZ/A1チップ依存部（GNU開発環境向け）は，arch/arm_gcc/rza1に置
かれている．

チップ略称等は次の通り．

	チップ略称：rza1
	開発環境略称：gcc

RZ/A1チップ依存部は，MPCore依存部（タイマ関係を除く）とGIC依存部を用い
ている．そのため，このドキュメント中でMPCore依存部（タイマ関係を除く）
とGIC依存部に関して記述されたことは，RZ/A1チップ依存部にも適用される．

ただし，RZ/Aシリーズの割込みコントローラは，標準のGICに対して独自の拡
張を加えているため，それに対応するため，GIC依存部に拡張を加えている．
また，RZ/A1に内蔵されているGICには，GIC-390 Errataと呼ばれる不具合があ
るため，「3.4 GIC-390 Errataへの対策」の節の記載事項に注意すること．

MPCore依存部のタイマ関係のコードを用いていないのは，RZ/Aシリーズでは，
MPCoreが持つタイマを使用できないためである．

1.6 その他のターゲット依存部

以下に挙げるARMの標準的なIP向けの定義ファイルや操作ライブラリ等が，
arch/arm_gcc/commonに置かれている．

・ARM L2キャッシュコントローラ（PL310）に関する定義と操作ライブラリ
・ARM PrimCell UART（PL011）用 簡易SIOドライバ


２．ターゲット定義事項の規定

この章では，TOPPERS第3世代カーネル（ITRON系）統合仕様書において，ター
ゲット定義とされている事項が，ARM依存部でどのように定義されているかに
ついて説明する．

2.1 データ型に関する規定

ターゲット依存のデータ型のサイズは次の通り．

	int_t			32ビット
	long_t			32ビット

	char			8ビット
	int_least8_t	8ビット
	void *			32ビット
	intptr_t		32ビット
	size_t			32ビット

ターゲット依存のデータ型の有無は次の通り．

	int8_t，uint8_t			あり
	int64_t，uint64_t		あり
	int128_t，uint128_t		なし
	float32_t				あり
	double64_t				あり

2.2 割込み処理に関する規定

ARMコア依存部の標準では，IRQをカーネル管理の割込み，FIQをカーネル管理外
の割込みと扱う．ただし，SafeGのセキュアモードでASP3カーネルを動作させる
場合には，FIQをカーネル管理の割込みとして扱い，カーネル管理外の割込みは
サポートしない．FIQに対する割込みハンドラは，DEF_INHではなく，DEF_EXCを
用いて登録する．

割込みサービスルーチンまたは割込みハンドラを登録していない割込みが発生
した場合，デフォルトの割込みハンドラが実行される．ターゲット依存部で変
更されていない場合，デフォルトの割込みハンドラでは，未登録の割込みが発
生したことをシステムログに出力する．

2.2.1 GIC依存部における割込み処理に関する規定

GIC依存部では，GICに対する割込みのID番号を，そのまま割込み番号として使
用している．また，割込みハンドラ番号は，それに対応する割込み番号と一致
させている．GICがサポートする割込みの種類と，その割込み番号の範囲は次
の通り．

	0～15				ソフトウェア生成割込み（SGI）
	16～31				コア毎のペリフェラルからの割込み（PPI）
	32～1019（最大）	共有ペリフェラルからの割込み（SPI）

GIC依存部では，割込み要求ラインの標準のトリガモードの設定をサポートし
ている．ただし，SGIに対しては，トリガモードを設定することができない．
また，PPIに対してトリガモードを設定できるかは，チップに依存する（いず
れも，コンフィギュレータはエラーを検出しない）．

GIC依存部では，TOPPERS第3世代カーネル（ITRON系）統合仕様書の規定に合致
した割込み要求禁止フラグをサポートしており，dis_intとena_intをサポート
している．ただし，SGIに対する割込み要求禁止フラグがサポートされるかは，
チップに依存する．サポートする場合には，ターゲット依存部で，
GIC_SUPPORT_DISABLE_SGIをマクロ定義する．

また，GIC依存部では，割込み要求のクリア，割込みの要求，割込み要求のチェッ
クをサポートしており，clr_int，ras_int，prb_intをサポートしている．た
だし，SGIに対する割込み要求のクリアはサポートおらず（GICのバージョンに
よってはサポートできないため），SGIに対してclr_intを呼び出すとE_PARエ
ラーとなる．レベルトリガの割込み要求ラインに対しても，ras_intで割込み
を要求することができ，clr_intは，ras_intで要求した割込み要求のみをクリ
アする（ハードウェアからレベルトリガで要求された割込み要求はクリアでき
ない）．

2.2.2 RZ/A1チップ依存部における割込み処理に関する規定

RZ/Aシリーズの割込みコントローラは，GICに独自の制御回路を追加したもの
になっており，32レベルの割込み優先度をサポートしている．そのため，割込
み優先度の最小値（最高値）は-31，割込み優先度の最大値（最低値）は-1で
ある．

RZ/Aシリーズの割込みコントローラがサポートする割込みの種類と，その割込
み番号の範囲は次の通り（個別の割込みについては，チップのマニュアルを参
照すること）．

	ソフトウェア割込み			0～15
	CPUからの割込み				16～19
	IRQ割込み					32～39
	内蔵周辺モジュール割込み	40～415
	端子割込み					416～537（RZ/A1Lの場合）
								416～586（RZ/A1H，RZ/A1Mの場合）

CPUからの割込みと内蔵周辺モジュール割込みは，レベルトリガで使用するかエッ
ジトリガで使用するかが，チップで決められている．チップでの指定と異なる
設定をした場合の動作は保証されない（異なる設定をしても，エラーにはなら
ない）．チップでの指定については，チップのマニュアルを参照すること．

IRQ割込みについては，GICの手前に独自の割込み入力制御回路が入っており，
その制御レジスタで，レベルトリガ，ポジティブエッジトリガ，ネガティブエッ
ジトリガ，両エッジトリガのいずれにするかを設定することができる．そこで，
IRQ割込みに対する割込み要求ラインの属性の設定（CFG_INT）では，以下のター
ゲット定義の割込み要求ライン属性を指定することができる．

	TA_NEGEDGE		0x04U		ネガティブエッジトリガ
	TA_POSEDGE		0x08U		ポジティブエッジトリガ
	TA_BOTHEDGE		0x0cU		両エッジトリガ

IRQ割込みに対してTA_EDGEを指定した場合，それ以外の割込みに対して上の3つ
の属性を指定した場合は，コンフィギュレータがエラーを検出する．

また，IRQ割込みをエッジトリガで使用する場合に，カーネルは，トリガした割
込み要求をクリアしない（カーネルの標準的な振舞いと異なる）．それに代え
て，トリガした割込み要求をクリアするための以下の関数を用意している．

(2-2-2-1) void rza1_clear_irq(INTNO intno)

intnoで指定したIRQ割込み要求をクリアする．intnoに指定できる値は，
INTNO_IRQ0～INTNO_IRQ7の範囲である．

IRQ割込みに対するclr_int，ras_int，prb_intは，GICを操作して実現してお
り，独自の制御回路は操作しない．そのため，カーネルの標準的な振舞いと異
なるため，注意が必要である．

2.3 CPU例外処理に関する規定

CPU例外ハンドラ番号は，以下のように割り当てている．

	EXCNO_UNDEF		0		未定義命令
	EXCNO_SVC		1		スーパバイザコール
	EXCNO_PABORT	2		プリフェッチアボート
	EXCNO_DABORT	3		データアボート
	EXCNO_IRQ		4		IRQ割込み
	EXCNO_FIQ		5		FIQ割込み
	EXCNO_FATAL		6		フェイタルデータアボート

この内，EXCNO_IRQに対しては，DEF_EXCによりCPU例外ハンドラを登録すること
ができない．

フェイタルデータアボート（EXCNO_FATAL）は，カーネル内のCPU例外入口処理
においてデータアボートが発生した場合に発生するエミュレートされたCPU例
外である．具体的には，スタックポインタが不正な値になった状態でCPU例外
が発生すると，CPU例外の入口処理で必要な情報をスタックに保存しようとし
て，再度CPU例外が発生する．これがフェイタルデータアボートである．フェ
イタルデータアボートは，カーネル管理外のCPU例外である．フェイタルデー
タアボートのCPU例外ハンドラからは，リターンしてはならない．

ARMでは，CPU例外ハンドラからリターンする場合に，戻り先のプログラムカウ
ンタの補正が必要になる．補正量は，例外の種類や，例外の原因になった命令
を再実行するかその次の命令から実行するかによって，以下の通りとなる．

例外の種類				戻り番地								補正量
----------------------------------------------------------------------
未定義命令				未定義命令の番地						-4/2(*)
						未定義命令の次の命令の番地				±0
スーパバイザコール		SVCの次の命令の番地						±0
プリフェッチアボート	アボートされた命令の番地				-4
						アボートされた命令の次の命令の番地		±0(**)
データアボート			アボートを生成した命令の番地			-8
						アボートを生成した命令の次の命令の番地	-4(**)
FIQ割込み				次に実行すべき番地						-4
----------------------------------------------------------------------
(*) ARMモードでは4，Thumbモードでは2
(**) ARMモードの場合

CPU例外ハンドラ内で戻り番地を補正する場合，以下のようなコードを実行すれ
ばよい（以下の例は，補正量が-4の場合）．

	((T_EXCINF *) p_excinf)->pc -= 4U

CPU例外ハンドラを登録していないCPU例外が発生した場合，デフォルトのCPU
例外ハンドラが実行される．ターゲット依存部で変更されていない場合，デフォ
ルトのCPU例外ハンドラでは，発生したCPU例外の種類と，CPU例外の発生状況
をシステムログに出力する．詳しくは，「3.2 CPU例外の原因の追及方法」の
節を参照すること．

2.4 タイマに関する規定

2.4.1 MPCore依存部におけるタイマに関する規定

MPCore依存部では，プロセッサ毎に持つプライベートタイマとウォッチドッグ，
各プロセッサからアクセスできるグローバルタイマを用いて，高分解能タイマ
とオーバランタイマを実現している．

具体的なタイマの使用方法やカーネルの構成マクロの値はターゲットシステム
毎に異なるため，ターゲット依存部のユーザーズマニュアルを参照すること．

2.4.2 RZ/A1チップ依存部におけるタイマに関する規定

RZ/A1チップ依存部では，RZ/Aシリーズが持つ2チャンネルのOSタイマの内の1つ
（OSタイマ0）を用いて高分解能タイマを，もう1つ（OSタイマ1）を用いてオー
バランタイマを実現している．

現在の実装では，OSタイマに供給されるクロックが33.33…MHz（CPUのクロック
が400MHz）の場合のみに対応している．この場合，高分解能タイマの周期
（TCYC_HRTCNT）は128,849,019（2^32÷33.33…を丸めた値），カウントアップ
の進み幅（TSTEP_HRTCNT）は1である．また，オーバランハンドラの残りプロセッ
サ時間に指定できる最大値（TMAX_OVRTIM）は128,849,017である．

2.5 FPUサポートに関する規定

ARMコア依存部は，2つの方法で，FPU（Advanced SIMDと浮動小数点拡張）をサ
ポートしている．標準的にはFPUを使用しない設定になっているため，FPUを使
用する場合には，以下のいずれかの記述に従って，FPUを使用するように設定
する必要がある．

2.5.1 FPUを常に使用する方法

すべての処理単位でFPUを使用できるようにする方法．タスク切換えや割込み
ハンドラ／CPU例外ハンドラの出入口でFPUレジスタを保存／復帰するため，オー
バヘッドが大きくなることに加えて，メモリ使用量も増加する．

この方法を用いる場合には，USE_ARM_FPU_ALWAYSをマクロ定義して，カーネル
とアプリケーションをコンパイルする（ターゲット依存部でマクロ定義されて
いる場合もある）．

また，コンパイラにFPU命令を出力させるために，以下のコンパイルオプショ
ンを与えることが必要である．

(1) 使用するCPU／FPUの指定

使用するCPUを指定するコンパイルオプションが，FPUなしのもの（例えば，
-mcpu=cortex-a9+nofp）になっている場合には，使用するFPUを指定するコン
パイルオプション（例えば，-mfpu=vfpv3-d16）を追加するか，使用するCPUを
FPUありのもの（例えば，-mcpu=cortex-a9）に変更する．

(2) コーリングコンベンションの指定

以下のいずれかのコンパイルオプションを追加する．

	-mfloat-abi=hard		FPUを使用する場合に最適化されたコーリング
							コンベンションを用いる（推奨）
	-mfloat-abi=softfp		FPUを使用しない場合と互換のコーリングコン
							ベンションを用いる

ARMコア依存部のFPUサポートでは，標準では，16個の64ビットレジスタ（D0～
D15）を用いることを想定している．32個の64ビットレジスタ（D0～D31）を用
いる場合には，USE_ARM_FPU_D32もマクロ定義してコンパイルする．

2.5.2 指定したタスクのみがFPUを使用する方法

FPUを使用する処理単位を，指定したタスクのみに限定する方法．具体的には，
TA_FPU属性のタスクのみが，FPUを使用できる．TA_FPU属性でないタスクやタ
スク以外の処理単位がFPU命令を使用した場合には，未定義命令例外が発生す
る．

この方法では，FPUレジスタの保存／復帰が，FPUを使用するタスクから／への
切換え時に限定されるため，オーバヘッドとメモリ使用量の増加を最小限に抑
えることができる．一方で，FPUを使用するタスク以外の処理単位がFPU命令を
使わないようにするのは，ユーザの責任となる．

この方法を用いる場合には，USE_ARM_FPU_SELECTIVEをマクロ定義して，カー
ネルとアプリケーションをコンパイルする（ターゲット依存部でマクロ定義さ
れている場合もある）．

FPUを使用しない処理単位がFPU命令を使わないようにするには，2つのアプロー
チが考えられる．

(a) FPUを使用しない処理単位では，浮動小数点数（float型やdouble型の数）
を使用しない

この方法は，コンパイラがソース言語レベルで浮動小数点数を使用していない
にも関わらずFPU命令を生成する場合には，適用できない．最新のGCCはこれに
該当するため，この方法は使用できない．

clangでは，-mno-implicit-floatにより，浮動小数点数を使用していない場合
にFPU命令の生成するのを抑止することができる．そのため，この方法を使用
することができると思われる（未検証）．

(b) コンパイルオプションを使って，FPU命令の生成を制御する

使用するCPU／FPUを指定するコンパイルオプションにより，FPU命令の生成を
制御することができる．具体的には，FPUを使用しない処理単位をコンパイル
する場合には，FPUなしのCPUを指定（例えば，-mcpu=cortex-a9+nofp）し，使
用するFPUは指定しない．FPUを使用する処理単位をコンパイルする場合には，
FPUありのCPUを指定（例えば，-mcpu=cortex-a9）するか，使用するFPUを指定
（例えば，-mfpu=vfpv3-d16）する．

この場合，FPUを使用するコードと使用しないコードをリンクするために，ABI
はsoftfpとする必要がある．具体的には，以下のコンパイルオプションを追加
する．

	-mfloat-abi=softfp		FPUを使用しない場合と互換のコーリングコン
							ベンションを用いる

ここで，ABIをhardに合わせることはできないのは，FPUなしのCPUを指定して
「-mfloat-abi=hard」を用いるとコンパイルエラーとなるためである．

ARMコア依存部のFPUサポートでは，標準では，16個の64ビットレジスタ（D0～
D15）をタスクのコンテキストに含める．コンテキストに32個の64ビットレジ
スタ（D0～D31）を含める場合には，USE_ARM_FPU_D32もマクロ定義してコンパ
イルする．

なお，タスク以外の処理単位でFPU命令を使用することは想定していないが，
使用したい場合には，破壊するFPUレジスタの保存／復帰と，浮動小数点演例
外制御レジスタ（FPEXC）のENビットの設定を処理単位の前後で行うことで，
FPUを使用することができる．

2.6 その他の規定・制約

タスクと非タスクコンテキスト用のスタック領域の先頭番地とサイズは，8の倍
数でなければならない．固定長メモリプール領域の先頭番地は，4の倍数でなけ
ればならない．

割込みサービスルーチンの先頭番地（CRE_ISRのisr）がプログラムの開始番地
として正しくない場合のエラーは，コンフィギュレータによって検出されない．
割込みハンドラの先頭番地（DEF_INHのinthdr）とCPU例外ハンドラの先頭番地
（DEF_EXCのexchdr）がプログラムの開始番地として正しくない場合のエラー
は，コンフィギュレータによって検出される．

2.7 動的生成機能拡張に関する規定

動的生成機能拡張パッケージをサポートしている．

動的メモリ管理に関して，ARM依存部では何も設定していない．そのため，ター
ゲット依存部で設定されていない場合，ターゲット非依存部で用意されている
デフォルトのメモリプール管理機能が使用される．


３．使用上の注意とヒント

3.1 MMUの設定

MMUを持つARMコアでは，MMUを使用しないとキャッシュを使用することができ
ない．そこで，ターゲット依存部で定義された有効なアドレスの範囲と，各ア
ドレス範囲におけるMMUへの設定属性（許可するアクセスの種類，キャッシュ
の設定等）に従って，ARMコア依存部では，MMUの変換テーブルを準備し，それ
を使用するように設定している．

MPCoreはMMUを持つため，MPCore依存部を使用する場合（RZ/A1チップ依存部を
使用する場合を含む）には，ターゲット依存部でMMUの設定情報を定義してい
る．

3.2 CPU例外の原因の追及方法

CPU例外ハンドラを登録していないCPU例外が発生すると，デフォルトのCPU例
外ハンドラ（default_exc_handler）が実行される．デフォルトのCPU例外ハン
ドラは，ターゲット依存部で変更されておらず，OMIT_XLOG_SYSが定義されて
いない場合，発生したCPU例外の種類と，CPU例外の発生状況をシステムログに
出力する．以下では，CPU例外の種類毎に，CPU例外の原因を追及する方法につ
いて説明する．

(1) 未定義命令例外

システムログに出力されるプログラムカウンタ（pc）の値は，未定義命令の次
の命令の番地である．その手前にある未定義命令を実行したことが，CPU例外の
原因である．

(2) スーパバイザコール（SVC）例外

システムログに出力されるプログラムカウンタ（pc）の値は，svc命令の次の命
令の番地である．その手前にあるsvc命令を実行したことが，CPU例外の原因で
ある．

(3) プリフェッチアボート

システムログに出力されるプログラムカウンタ（pc）の値は，(アボートされた
命令フェッチの番地+4)である．

プリフェッチアボートは，不正な番地への分岐によって起こるのが一般的であ
るが，その場合，プログラムカウンタの値は，(分岐先の番地+4)となる．CPU例
外の発生原因は分岐元の命令であるが，システムログに出力される情報から分
岐元を知る方法はない．ただし，関数呼出しによる分岐の場合には，リンクレ
ジスタ（lr）に戻り番地が保存されるため，リンクレジスタが指す命令の手前
の分岐命令が，CPU例外の原因ということになる．

(4) データアボート

システムログに出力されるプログラムカウンタ（pc）の値は，(データアボート
を起こした命令番地+8)である．(プログラムカウンタの値-8)の番地にある命令
を実行したことが，CPU例外の原因である．

(5) フェイタルデータアボート

システムログに出力されるプログラムカウンタ（pc）の値は，カーネル内の
CPU例外入口処理内の番地となる．この場合，最初のCPU例外が起こった状況が
保存されていないため，CPU例外の原因の追及は難しい．

(6) アボート発生の状況

プリフェッチアボートやデータアボート発生の詳しい状況を知るために，CP15
に以下のレジスタが用意されている．

ARMv7では，以下のレジスタが用意されている．

	DFSR（Instruction Fault Status Register）	cp15 c5 0 c0 0
	DFAR（Instruction Fault Address Register）	cp15 c6 0 c0 0
	IFSR（Instruction Fault Status Register）	cp15 c5 0 c0 1
	IFAR（Instruction Fault Address Register）	cp15 c6 0 c0 2

ARMv6は，ARMv6の持つ4つのレジスタ内，IFARはオプションである．また，
DFARはFAR（Fault Address Register）と呼ばれている．

ARMv5以前は，以下のレジスタが用意されている．

	FSR（Fault Status Register）	cp15 c5 0 c0 0
	FAR（Fault Address Register）	cp15 c6 0 c0 0

3.3 パフォーマンスモニタによる性能評価

ARMv7に準拠したパフォーマンスモニタを持つターゲットシステムでは，
USE_ARM_PM_HISTを定義してコンパイルすることで，実行時間分布集計サービス
において，パフォーマンスモニタを用いて実行時間を計測する．実行時間の計
測単位は，0.1マイクロ秒としている．

3.4 GIC-390 Errataへの対策

GIC-390 Errataと呼ばれる不具合があるチップを使用しているターゲットシス
テムでは，ターゲット依存部でGIC_PL390_ERRATAをマクロ定義することで，カー
ネルにGIC-390 Errataへの対策が組み込まれるが，アプリケーション側でも以
下の対処が必要である．

割込み番号0の割込み（SGI 0）を使用しないことを推奨する．やむを得ず使用
する場合には，この割込みに対して登録した割込みハンドラ／割込みサービス
ルーチンが不必要に呼び出されても，問題が起こらないようにしなければなら
ない．

カーネル管理外の割込みとしてFIQを使用する場合，FIQを受け付けた直後に，
割込み優先度レジスタ0（GICD_IPRIORITYR0）に設定値と同じ値を書き込む必
要がある．また，FIQからリターンする直前に，GICC_HPPIRをダミーリードす
る必要がある．


４．リファレンス

4.1 ディレクトリ構成・ファイル構成

	arm_gcc/
		MANIFEST				個別パッケージのファイルリスト

	arm_gcc/common/
		Makefile.core			Makefileのコア依存部
		arm.h					コアのハードウェア資源の定義
		arm_insn.h				コア独自の命令の実行
		core_asm.inc			アセンブラ記述のためのマクロ
		core_cfg1_out.h			cfg1_out.cのリンクに必要なスタブの定義
		core_check.trb			kernel_check.trbのコア依存部
		core_kernel.h			kernel.hのコア依存部
		core_kernel.trb			kernel.trbのコア依存部
		core_kernel_impl.c		カーネル実装のコア依存部
		core_kernel_impl.h		カーネル実装のコア依存部関連の定義
		core_offset.trb			genoffset.trbのコア依存部
		core_rename.def			コア依存部の内部識別名のリネーム定義
		core_rename.h			コア依存部の内部識別名のリネーム
		core_sil.h				sil.hのコア依存部
		core_stddef.h			t_stddef.hのコア依存部
		core_support.S			カーネル実装のコア依存部（アセンブリ言語
								で記述した部分）
 		core_sym.def			kernel_sym.defのコア依存部
		core_syssvc.h			システムサービスのコア依存定義
		core_test.h				テストプログラムのコア依存定義
		core_unrename.h			コア依存部の内部識別名のリネーム解除
		gic_kernel_impl.c		カーネル実装のGIC依存部関連の定義
		gic_kernel_impl.h		カーネル実装のGIC依存部
		gic_support.S			カーネル実装のGIC依存部関連（アセンブリ言
								語で記述した部分）
		mpcore.h				MPCoreのハードウェア資源の定義
		mpcore_kernel_impl.c	カーネル実装のMPCore依存部
		mpcore_kernel_impl.h	カーネル実装のMPCore依存部関連の定義
		mpcore_timer.c			MPCoreの内蔵タイマ用のタイマドライバ
		mpcore_timer.cfg		MPCoreの内蔵タイマ用のタイマドライバのコン
								フィギュレーションファイル
		mpcore_timer.h			MPCoreの内蔵タイマ用のタイマドライバを使用
								するための定義
		pl310.c					L2キャッシュコントローラ（PL310）の操作ライ
								ブラリ
		pl310.h					L2キャッシュコントローラ（PL310）に関する定義
		start.S					カーネル用のスタートアップモジュール（ARM用）
		tUartPL011.c			ARM PrimCell UART（PL011）用 簡易SIOドライバ
		tUartPL011.cdl			ARM PrimCell UART（PL011）用 簡易SIOドライ
								バのコンポーネント記述
		uart_pl011.h			ARM PrimCell UART（PL011）に関する定義

	arm_gcc/rza1/
		MANIFEST				RZ/A1依存部のファイルリスト
		Makefile.chip			Makefileのチップ依存部
		chip_kernel.h			kernel.hのチップ依存部
		chip_kernel.trb			kernel.trbのチップ依存部
		chip_kernel_impl.c		カーネル実装のチップ依存部
		chip_kernel_impl.h		カーネル実装のチップ依存部関連の定義
		chip_rename.def			チップ依存部の内部識別名のリネーム定義
		chip_rename.h			チップ依存部の内部識別名のリネーム
		chip_stddef.h			t_stddef.hのチップ依存部
		chip_sym.def			kernel_sym.defのチップ依存部
		chip_timer.c			タイマドライバ
		chip_timer.cfg			タイマドライバのコンフィギュレーションファイル
		chip_timer.h			タイマドライバを使用するための定義
		chip_unrename.h			チップ依存部の内部識別名のリネーム解除
		rza1.h					チップのハードウェア資源の定義
		scif.h					シリアルインタフェースに関する定義
		tSCIF.c					シリアルインタフェース用 簡易SIOドライバ
		tSCIF.cdl				シリアルインタフェース用 簡易SIOドライバ
								のコンポーネント記述
		tSIOPortRZA1.cdl		シリアルインタフェースドライバのターゲッ
								ト依存部のコンポーネント記述
		tSIOPortRZA1Main_inline.h	シリアルインタフェースドライバのター
									ゲット依存部

	arm_gcc/doc/
		arm_design.txt			ARMコア依存部 設計メモ
		arm_porting.txt			ターゲット依存部 ポーティングガイド（ARM向け）
		arm_user.txt			ARM依存部 ユーザーズマニュアル
		gic_design.txt			GIC依存部 設計メモ

	arm_gcc/test/			ARM向けテストプログラム
		arm_cpuexc1.c			ARM向けCPU例外処理のテスト(1)
		arm_cpuexc1.cfg
		arm_fpu1.c				ARM向けFPUのテスト(1)
		arm_fpu1.cfg

4.2 バージョン履歴

	2015年8月5日	Release	3.B.0		最初のリリース
	2016年2月8日	Release	3.0.0		最初の一般公開
	2016年5月15日	Release	3.1.0		RZ/A1のサポートを追加
	2017年7月21日	Release	3.2.0
	2018年4月19日	Release	3.3.0
	2019年3月20日	Release	3.4.0		MPCore依存部の構成を変更，
										FPUサポートを追加
	2019年10月6日	Release	3.5.0
	2020年12月23日	Release	3.6.0
	2023年3月14日	Release	3.7.0
	2023年4月11日	Release	3.7.1

以上
