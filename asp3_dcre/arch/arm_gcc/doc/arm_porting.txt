
		TOPPERS/ASP3カーネル
		ターゲット依存部 ポーティングガイド（ARM向け）

		対応バージョン: Release 3.7.1
		最終更新: 2023年3月5日

このドキュメントは，TOPPERS/ASP3カーネルのARM依存部を使用して，ASP3カー
ネルを未サポートのターゲットシステムにポーティングするために必要となる
ターゲット依存部の実装方法を説明するものである．

このドキュメントは，「ターゲット依存部 ポーティングガイド」と「ARM依存
部 ユーザーズマニュアル」の記述を前提に記述している．

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2014-2023 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: arm_porting.txt 1809 2023-04-11 07:45:05Z ertl-hiro $
----------------------------------------------------------------------

○目次

１．ARM依存部とそれを用いたターゲット依存部の実装方法の概要
	1.1 ARM依存部の構成
	1.2 ターゲット依存部の実装方法の概要
２．システム構築環境のターゲット依存部
３．TOPPERS共通定義のターゲット依存部
４．システムインタフェースレイヤ（SIL）のターゲット依存部
５．カーネルAPIのターゲット依存部
	5.1 MPCore依存部を用いる場合
	5.2 GIC依存部を用いる場合
６．カーネル実装のターゲット依存部
	6.1 ARM依存部の取り込み方法
		6.1.1 ARMコア依存部のみを用いる場合
		6.1.2 MPCore依存部を用いる場合
		6.1.3 GIC依存部を用いる場合
	6.2 割込みに関連するシステム状態の管理
		6.2.1 ARMコア依存部のみを用いる場合
		6.2.2 GIC依存部を用いる場合
	6.3 割込みハンドラ
		6.3.1 割込みハンドラの出入口処理
		6.3.2 割込みハンドラに関するその他の設定
	6.4 CPU例外ハンドラとCPU例外発生時のシステム状態の参照
	6.5 カーネルの起動・終了とスタック領域など
		6.5.1 MMUの設定
		6.5.2 その他の設定
	6.6 カーネル実装に関するその他の定義
	6.7 カーネル実装のターゲット依存部のためのリネーム記述
	6.8 高分解能タイマドライバとオーバランタイマドライバ
		6.8.1 MPCore依存部を用いる場合
			6.8.1.1 プライベートタイマとウォッチドッグで高分解能タイマを実現
			6.8.1.2 グローバルタイマで高分解能タイマを実現
			6.8.1.3 ウォッチドッグでオーバランタイマを実現
	6.9 FPUサポートに関する定義
７．コンフィギュレータ設定ファイルのターゲット依存部
	7.1 値取得シンボルテーブル
	7.2 パス2の生成スクリプトのターゲット依存部
	7.3 パス3の生成スクリプトのターゲット依存部
	7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル
８．システムサービス等のターゲット依存部
	8.1 システムサービスのコア依存部
	8.2 サンプルプログラムとテストプログラムのコア依存部
	8.3 ARM PrimCell UART（PL011）用 簡易デバイスドライバ
９．その他


１．ARM依存部とそれを用いたターゲット依存部の実装方法の概要

ARM依存部は，TOPPERS/ASP3カーネルのターゲット依存部の中で，ARMv4，
ARMv5，ARMv6，ARMv7-A，ARMv7-R，ARMv8-AのAArch32，ARMv8-Rに準拠したプ
ロセッサコアを用いたターゲットシステムに共通に使用できる部分である．

ただし，これらのバージョンのプロセッサコアのすべてに対応できることは確
認しておらず（実際に動作確認したコアは限られたもののみである），ARM依
存部に修正が必要になる場合もある．また，現時点では，GNU開発環境のみに
対応している．

1.1 ARM依存部の構成

このドキュメントで扱うARM依存部は，ARMコア依存部，MPCore依存部，GIC依
存部で構成される．ARM依存部の配布パッケージには，この他に，RZ/A1チップ
依存部も含まれているが，このドキュメントでは扱っていない．

ARMコア依存部は，ターゲット依存部の中で，ARMのプロセッサコアのみに依存
する部分である．GIC依存部は，プロセッサコアに加えて，ARMの標準的な割込
みコントローラの1つであるGIC（ARM Generic Interrupt Controller，現時点
ではバージョン2以前のGICのみに対応）に依存する部分である．MPCore依存部
は，プロセッサコアとGICに加えて，ARM MPCoreアーキテクチャに基づいたプ
ロセッサコアに依存する部分である．MPCoreアーキテクチャはGICを含んでい
ることから，MPCore依存部を用いると，GIC依存部も用いることになる．

ASP3カーネルのターゲット依存部の構成については「ターゲット依存部 ポー
ティングガイド」に，ARM依存部の構成の詳細については「ARM依存部 ユーザー
ズマニュアル」に記載されているため，これらのドキュメントも参照すること．

1.2 ターゲット依存部の実装方法の概要

ターゲット依存部を実装するには，基本的には，「ターゲット依存部 ポーティ
ングガイド」の１章～９章の説明に従って，必要なファイルを作成する必要が
ある．

新しいターゲット依存部を作成する時は，まず，「ターゲット依存部 ポーティ
ングガイド」の1.1節に説明されている通り，ターゲット略称を定め，target
ディレクトリの下に，ターゲット依存部ディレクトリを作成する．

また，ターゲット依存部からチップ依存部を切り分ける場合には，チップ略称
を定め，arch/arm_gccディレクトリの下に，チップ依存部ディレクトリを作成
する．なお，ARM依存部を用いる場合，チップ依存部ディレクトリの名称には，
開発環境略称を含める必要はない．

ARM依存部には，ARMコア，MPCore，GICに依存して用意できる設定や実装コー
ドが含まれているため，それらの設定や実装コードがそのままで使える場合に
は，ARM依存部のファイルを用いるだけで良い．それらの設定や実装コードに
ターゲットに依存する設定を追加する必要がある場合や，設定や実装コードが
用意されていない場合には，ターゲット依存部で対応する必要がある．

以下では，「ターゲット依存部 ポーティングガイド」の２章～９章の説明に
沿って，ターゲット依存部で対応が必要となる（可能性がある）設定について
説明する．

なお，ターゲット依存部からチップ依存部を切り分ける場合には，このドキュ
メントでターゲット依存部で行うものとしている設定を，ターゲット依存部と
チップ依存部のいずれかで行えばよい．


２．システム構築環境のターゲット依存部

前述の通り，ARM依存部は，現時点ではGNU開発環境のみに対応している．ARM
向けのGNU開発環境としては，以下のURLからプリビルド版をダウンロードする
ことができるGNU ARM Embedded Toolchainを用いている（Cortex-MとCortex-R
向けの開発環境であるが，Cortex-A向けにも使用できる）．

	https://developer.arm.com/open-source/gnu-toolchain/gnu-rm

以下，この章では，ARM依存部を使用した場合に，Makefileのターゲット依存
部に記述すべき内容について説明する．

Makefileのターゲット依存部に記述すべきARM依存部のための設定は次の通り．

・変数CDEFSに，__TARGET_ARCH_ARMをARMのアーキテクチャバージョン（4～8
　のいずれか）をマクロ定義する記述を追加設定する．

・ASP3カーネルをSafeGのセキュアモードで動作させる場合には，変数CDEFSに，
　TOPPERS_SAFEG_SECUREをマクロ定義する記述を追加設定する．

この他は，「ターゲット依存部 ポーティングガイド」の2.1節～2.8節の説明
に従って，Makefileのターゲット依存部を作成する．

ここで，MakefileのARMコア依存部（Makefile.core）に記述されている内容が
使える場合には，このファイルをインクルードすることで省略することができ
る．特に，Makefile.coreをインクルードし，core_offset.trbを用いることで，
オフセットファイルの生成方法はARMコア依存部に任せられる場合が多い．ま
た，ARMコア依存部で用意されているスタートアップモジュールがそのまま使
える場合には，スタートアップモジュールに関する設定も，ARMコア依存部に
任せることができる．


３．TOPPERS共通定義のターゲット依存部

「ターゲット依存部 ポーティングガイド」の3.1節と3.7節～3.8節で説明され
ている設定については，TOPPERS共通定義のターゲット依存部（target_stddef.h）
に記述する必要がある．3.2節～3.6節の内容については，前述のARM向けのGNU
開発環境を用いている場合には，以下の記述をtarget_stddef.hに含めること
で，ARMコア依存部およびGNU開発環境依存部に任せることができる．

----------------------------------------
/*
 *  開発環境で共通な定義
 *
 *  開発環境でstdint.hが用意されている場合には，TOPPERS_STDINT_TYPE1の
 *  マクロ定義を削除し，stdint.hをインクルードすればよい．
 */
#define TOPPERS_STDINT_TYPE1
#define TOPPERS_STDFLOAT_TYPE1
#include "tool_stddef.h"

/*
 *  コアで共通な定義
 */
#include "core_stddef.h"
----------------------------------------

前述のARM向けのGNU開発環境にはstdint.hが用意されているため，上のコメン
トに従って，TOPPERS_STDINT_TYPE1のマクロ定義を削除し，stdint.hをインク
ルードしてもよい．


４．システムインタフェースレイヤ（SIL）のターゲット依存部

システムインタフェースレイヤ（SIL）のターゲット依存部（target_sil.h）
では，「ターゲット依存部 ポーティングガイド」の4.3節で説明されているプ
ロセッサのエンディアンを指定するマクロ（SIL_ENDIAN_BIGまたは
SIL_ENDIAN_LITTLE）を定義した後，システムインタフェースレイヤのARMコア
依存部（core_sil.h）をインクルードする．

これに加えて，カーネル実装のターゲット依存部のヘッダファイル
（target_kernel_impl.h）に，SIL_DLY_TIM1とSIL_DLY_TIM2の定義を含める必
要がある．これらの定数の意味と決定方法は，「ターゲット依存部 ポーティ
ングガイド」の4.2節で説明されている．なお，sil_dly_nseはARMコア依存部
に含まれているため，ターゲット依存部で用意する必要はない．

SIL_DLY_TIM1とSIL_DLY_TIM2の定義は，本来はSIL実装のターゲット依存部に
含めるべき内容であるが，ファイルの数を増やさないように，カーネル実装の
ターゲット依存部に含めている．


５．カーネルAPIのターゲット依存部

「ターゲット依存部 ポーティングガイド」の5.1節～5.3節と5.7節で説明され
ている設定については，カーネルAPIのターゲット依存部（target_kernel.h）
に記述する必要がある．5.4節～5.6節で説明されている設定については，カー
ネルAPIのARMコア依存部（core_kernel.h）をインクルードすることで，ARMコ
ア依存部に任せることができる．

5.1 MPCore依存部を用いる場合

MPCore依存部に含まれるタイマドライバを用いて高分解能タイマを実現する場
合には5.3節，オーバランタイマを実現する場合には5.7節で説明されている定
義が定まる．詳しくは，「6.8.1 MPCore依存部を用いる場合」の節を参照す
ること．

5.2 GIC依存部を用いる場合

GIC依存部を用いる場合には，dis_int，ena_int，clr_int，ras_int，prb_int
はすべてサポートされるため，target_kernel.hで，そのことを表すシンボル
（「ターゲット依存部 ポーティングガイド」の5.1節で説明されている
TOPPERS_TARGET_SUPPORT_DIS_INT等の5つのシンボル）をすべてマクロ定義す
る．

また，5.2節で説明されているTMAX_INTPRIは，ターゲットシステムのGICでサ
ポートされている割込み優先度の段数により，-15，-31，-63，-127，-255の
いずれかに定義する．


６．カーネル実装のターゲット依存部

「ターゲット依存部 ポーティングガイド」の６章の内容に対するARM依存部の
対応の有無と，ターゲット依存部での対応の必要性は次の通り．

	6.1節	カーネル実装のターゲット依存部を作成するにあたって理解して
			おくべき事項の説明であり，理解しておくことが必要
	6.2節	ARMコア依存部で対応している
	6.3節	ARMコア依存部で対応している
	6.4節	ARMコア依存部では対応していない．GIC依存部が対応している
	6.5節	ARMコア依存部で対応している
	6.6節	ARMコア依存部で対応している部分と，ターゲット依存部で対応す
			べき部分がある．GIC依存部は後者の部分に対応している
	6.7節	ARMコア依存部で対応している部分と，ターゲット依存部で対応す
			べき部分がある．GIC依存部は後者の部分に対応している
	6.8節	ARMコア依存部で対応している部分と，ターゲット依存部で対応す
			べき部分がある
	6.9節	ARMコア依存部で対応している
	6.10節	ARMコア依存部で大部分に対応しているが，一部をターゲット依存
			部で対応する必要がある
	6.11節	ARM依存部では対応していない．必要であれば，ターゲット依存部
			で対応する必要がある
	6.12節	カーネル実装のターゲット依存部を作成するにあたって共通に実
			施すべき事項の説明であり，ターゲット依存部でも対応すること
			が必要
	6.13節	ARMコア依存部では対応していない．MPCore依存部が対応している
	6.14節	ARMコア依存部では対応していない．MPCore依存部が対応できる場
			合がある
	6.15節	ARM依存部では対応していない．必要であれば，ターゲット依存部
			で対応する必要がある
	6.16節	ターゲット依存部で対応する必要がある

以下，この節では，ARM依存部が何らかの対応をしている項目において，ター
ゲット依存部で対応する必要がある事項について説明する．6.11節，6.15節，
6.16節の内容は，ARM依存部では対応しておらず，ターゲット依存部における
対応は「ターゲット依存部 ポーティングガイド」に従えばよいため，以下で
は説明を行わない．

6.1 ARM依存部の取り込み方法

ARM依存部（ARMコア依存部，MPCore依存部，GIC依存部）が対応している項目
については，ターゲット依存部で以下の設定を行うことにより，ARM依存部に
任せることができる．

6.1.1 ARMコア依存部のみを用いる場合

ARMコア依存部のみを用いる場合，以下の設定を行う．

・カーネル実装のターゲット依存部のヘッダファイル（target_kernel_impl.h）
　から，ARM依存部のヘッダファイル（core_kernel_impl.h）をインクルード
　する．

・カーネル実装のコア依存部（core_kernel_impl.c，core_support.S）を，ロー
　ドモジュールに組み込む．Makefile.coreには，そのための記述が含まれて
　いる．

・ターゲット依存部の初期化関数（target_initialize）から，ARM依存部の初
　期化関数（core_initialize）を呼び出す．また，ターゲット依存部の終了
　処理関数（target_exit）から，ARM依存部の終了処理関数（core_terminate）
　を呼び出す．なお，target_exitは，ARM依存部の終了処理関数を呼び出した
　後に，ターゲットシステムを終了させる．

・カーネル実装のターゲット依存部のリネーム記述（target_rename.def）か
　ら，コア依存部のリネーム記述をインクルードする．具体的には，
　target_rename.defに「INCLUDE "core"」の行を含める．

・コンフィギュレータのパス2の生成スクリプトのターゲット依存部
　（target_kernel.trb）とパス3の生成スクリプトのターゲット依存部
　（target_check.trb）から，それぞれのコア依存部（core_kernel.trbと
　core_check.trb）をインクルードする．

・コンフィギュレータの値取得シンボルテーブルのコア依存部（core_sym.def）
　を用いるように設定する．Makefile.coreには，そのための記述が含まれて
　いる．

6.1.2 MPCore依存部を用いる場合

MPCore依存部を用いる場合（前述の通り，MPCore依存部を用いると，GIC依存
部も用いられる）には，target_kernel_impl.hにおいて，以下の3つのシンボ
ルをマクロ定義する．

(6-1-2-1) MPCORE_PMR_BASE	MPCoreのPrivate Memory Regionの先頭番地
(6-1-2-2) GICC_BASE			GICのCPUインタフェースのベースアドレス
(6-1-2-3) GICD_BASE			GICのディストリビュータのベースアドレス

また，L2キャッシュを操作するための以下の4つの関数を定義する．

(6-1-2-4) arm_enable_outer_cache(void)		L2キャッシュのイネーブル
(6-1-2-5) arm_disable_outer_cache(void)		L2キャッシュのディスエーブル
(6-1-2-6) arm_invalidate_outer_cache(void)	L2キャッシュの無効化
(6-1-2-7) arm_clean_outer_cache(void) 		L2キャッシュのクリーン

ARMコア依存部のみを用いる場合の設定を，以下のように変更する．

・target_kernel_impl.hからインクルードするARM依存部のヘッダファイルは，
　mpcore_kernel_impl.hとする．上の3つのシンボルは，mpcore_kernel_impl.h
　をインクルードする前にマクロ定義する．

・target_initializeから呼び出すARM依存部の初期化関数は，
　mpcore_initializeとする．また，target_exitから呼び出すARM依存部の終
　了処理関数は，mpcore_terminateとする．

さらに，以下の設定を追加する．

・カーネル実装のMPCore依存部（mpcore_kernel_impl.c，mpcore_timer.c：
　MPCore依存部のタイマドライバを用いる場合のみ）とGIC依存部
　（gic_kernel_impl.c，gic_support.S）を，ロードモジュールに組み込む．
　具体的には，Makefileのターゲット依存部で，変数KERNEL_COBJSに
　mpcore_kernel_impl.o，gic_kernel_impl.o，mpcore_timer.oを，変数
　KERNEL_ASMOBJSにgic_support.oを追加設定する．

6.1.3 GIC依存部を用いる場合

MPCore依存部を用いずに，GIC依存部を用いる場合には，
target_kernel_impl.hにおいて，以下の2つのシンボルをマクロ定義する．

(6-1-3-1) GICC_BASE		GICのCPUインタフェースのベースアドレス
(6-1-3-2) GICD_BASE		GICのディストリビュータのベースアドレス

また，ARMコア依存部のみを用いる場合の設定を，以下のように変更する．

・target_kernel_impl.hからインクルードするARM依存部のヘッダファイルは，
　gic_kernel_impl.hとする．上の2つのシンボルは，gic_kernel_impl.hをイ
　ンクルードする前にマクロ定義する．

・target_initializeから呼び出すARM依存部の初期化関数は，
　gicd_initializeとgicc_initializeとする．また，target_exitから呼び出
　すARM依存部の終了処理関数は，gicd_terminateとgicc_terminateとする．

さらに，以下の設定を追加する．

・カーネル実装のGIC依存部（gic_kernel_impl.c，gic_support.S）を，ロー
　ドモジュールに組み込む．具体的には，Makefileのターゲット依存部で，変
　数KERNEL_COBJSにgic_kernel_impl.oを，変数KERNEL_ASMOBJSに
　gic_support.oを追加設定する．

6.2 割込みに関連するシステム状態の管理

ARMコアは割込みコントローラを含まないため，「ターゲット依存部 ポーティ
ングガイド」の6.4節の内容はすべてターゲット依存部で対応する必要がある．

6.2.1 ARMコア依存部のみを用いる場合

ARMコア依存部のみを用いる場合，target_kernel_impl.hから
core_kernel_impl.hをインクルードする前に，必要に応じて以下のシンボルを
マクロ定義する．

(6-2-1-1) USE_INTCFG_TABLE		

check_intno_cfgの実装を容易にするために，各割込み要求ラインの割込み属
性が設定されているかどうかを保持するテーブル（intcfg_table）をARM依存
部で用意する必要がある場合には，このシンボルをマクロ定義する．このシン
ボルをマクロ定義した場合，check_intno_cfgは次のように実装できる．

----------------------------------------
bool_t
check_intno_cfg(INTNO intno)
{
	return(intcfg_table[intno] != 0U);
}
----------------------------------------

なお，GIC依存部を用いる場合には，このシンボルはGIC依存部でマクロ定義さ
れるため，ターゲット依存部では定義する必要がない．

6.2.2 GIC依存部を用いる場合

GIC依存部を用いる場合，target_kernel_impl.hからgic_kernel_impl.h（また
は，mpcore_kernel_impl.h）をインクルードする前に，以下のシンボルをマク
ロ定義することで，「ターゲット依存部 ポーティングガイド」の6.4節の内容
に対応することができる．

(6-2-2-1) GIC_TNUM_INTNO

ターゲットシステムのGICがサポートする割込みの数．SGI（Software
Generated Interrupt），PPI（Private Peripheral Interrupt），
SPI（Shared Peripheral Interrupt）の合計数．

(6-2-2-2) GIC_ARM11MPCORE（必要な場合）

GICの割込みコンフィギュレーションレジスタで，各割込みのコンフィギュレー
ション情報の下位ビットを1に設定すべき場合には，このシンボルをマクロ定
義する．ARM11 MPCoreのDistributed Interrupt Controllerの場合には，この
シンボルをマクロ定義する必要がある．

(6-2-2-3) GIC_SUPPORT_DISABLE_SGI（必要な場合）

GICの割込みイネーブルセット／クリアレジスタにより，SGIの割込み要求禁止
フラグがセット／クリアできる場合に，このシンボルをマクロ定義する．なお，
これができるかどうかは，GIC仕様では実装定義となっており，Cortex-A9およ
びPL390ではできない仕様となっている．

(6-2-2-4) OMIT_GIC_INITIALIZE_INTERRUPT（必要な場合）

GIC依存部の標準の割込み管理機能の初期化処理（initialize_interrupt）を
使わず，ターゲット依存部でそれに代わる初期化処理を用意する場合には，こ
のシンボルをマクロ定義する．

(6-2-2-5) GIC_PL390_ERRATA（必要な場合）

一部のGICの実装には，GIC-390 Errataと呼ばれる不具合があることが知られ
ている．不具合があるチップを使用する場合には，このシンボルをマクロ定義
する．

6.3 割込みハンドラ

6.3.1 割込みハンドラの出入口処理

「ターゲット依存部 ポーティングガイド」の6.6.1節で説明されている割込み
ハンドラの出入口処理は，ARMコア依存部で実装されているが，そこから呼び
出す割込みコントローラの操作関数は，ターゲット依存部で実装する必要があ
る．なお，GIC依存部を用いる場合には，これらの関数はGIC依存部に含まれて
いるため，ターゲット依存部で用意する必要はない．

(6-3-1) irc_begin_int

割込みハンドラの入口で必要な割込みコントローラの操作を行うルーチン．受
け付けた割込み要求を特定した後，割込み優先度マスクを受け付けた割込み要
求の割込み優先度に設定し，受け付けた割込み要求の割込み番号（0から始ま
る番号で，割込みハンドラ番号と一致させる）をr4に返す．スプリアス割込み
の場合には，割込み番号の最大値より大きい値をr4返す．

また，irc_end_intで必要となる情報（変更する前の割込み優先度マスク等）
をスタックに保存する．必要な情報を保存するために，スタックの先頭の1ワー
ドを利用することができる．保存が必要な情報が1ワードより大きい場合には，
irc_begin_intで情報をスタックに積み，irc_end_intでスタックから取り出す
ように実装する．

(6-3-2) irc_end_int

割込みハンドラの出口で必要な割込みコントローラの操作を行うルーチン．割
込み優先度マスクを，割込みを受け付ける前の値に戻す．

6.3.2 割込みハンドラに関するその他の設定

「ターゲット依存部 ポーティングガイド」の6.6.4節～6.6.5節の内容は，ター
ゲット依存部で対応する必要がある．

ARMコア依存部では，割込みハンドラの初期化に必要な情報（inhinib_table等）
をkernel_cfg.cに生成する必要がないため，OMIT_INITIALIZE_INTERRUPTをマ
クロ定義している．そのため，initialize_interruptをターゲット依存部で用
意する必要がある．また，割込み要求ラインの初期化に必要な情報
（intinib_table等）をkernel_cfg.cに生成したい場合には，
USE_INTINIB_TABLEをマクロ定義する必要がある．

GIC依存部を使用し，OMIT_GIC_INITIALIZE_INTERRUPTをマクロ定義していない
場合，これらはGIC依存部で対応しているため，ターゲット依存部で対応する
必要はない．

「ターゲット依存部 ポーティングガイド」の6.6.2節～6.6.3節および6.6.6節～
6.6.7節の内容は，ターゲット依存部では対応する必要がない．6.6.8節の内容
は，必要であればターゲット依存部で対応する必要がある．

6.4 CPU例外ハンドラとCPU例外発生時のシステム状態の参照

「ターゲット依存部 ポーティングガイド」の6.6.1節で説明されているCPU例
外ハンドラの出入口処理は，ARMコア依存部で実装されているが，そこから呼
び出す割込みコントローラの操作関数は，ターゲット依存部で実装する必要が
ある．なお，GIC依存部を用いる場合には，これらの関数はGIC依存部に含まれ
ているため，ターゲット依存部で用意する必要はない．

(6-4-1) irc_get_intpri

CPU例外発生時の割込み優先度マスクを読み出すルーチン．読み出した割込み
優先度マスクの値は，外部表現の形式でr0に返す．読み出した割込み優先度マ
スクの値は，CPU例外がタスクコンテキストで発生した場合にのみ使われるた
め，非タスクコンテキストで発生した場合には，正しい値を返す必要がない．
	 
(6-4-2) irc_begin_exc

irc_end_excで必要となる情報（CPU例外発生時の割込み優先度マスク等）をス
タックに保存するルーチン．必要な情報を保存するために，スタックの先頭の
1ワードを利用することができる．

(6-4-3) irc_end_exc

割込み優先度マスクを，CPU例外発生時の値に戻す．

「ターゲット依存部 ポーティングガイド」の6.7.2節～6.7.6節の内容は，ARM
コア依存部で対応している（または，対応する必要がない）．

6.5 カーネルの起動・終了

「ターゲット依存部 ポーティングガイド」の6.8節で説明されているスタート
アップモジュールは，ARMコア依存部で標準的なものが用意されている
（start.S）．ARMコア依存部で用意されているスタートアップモジュールには，
hardware_init_hookとsoftware_init_hookを呼び出す処理を入れているため，
ターゲット依存部でそれらを用意することで多くのターゲットシステムに対応
できると思われる．用意されているスタートアップモジュールがそのままでは
使えない場合には，ターゲット依存部で用意する必要がある．

「ターゲット依存部 ポーティングガイド」の6.8節で説明されている
target_initializeとtarget_exitは，ターゲット依存部で用意する必要がある．
call_exit_kernelは，ARMコア依存部で用意されているため，ターゲット依存
部で用意する必要はない．

ターゲットシステムが，ARM L2キャッシュコントローラ（PL310）を用いてい
る場合には，target_initialize（またはチップ依存部）で，ARM L2キャッシュ
コントローラ（PL310）に関する定義と操作ライブラリを使用することができ
る．

6.5.1 MMUの設定

MMUを持つARMコアでは，ある番地に対してキャッシュを有効とするかどうかを，
MMUによって設定する．そのため，MMUを使用しないとキャッシュを使用するこ
とができない．そこで，ARMコア依存部では，ターゲット依存部で定義された
有効なアドレスの範囲と，各アドレス範囲におけるMMUへの設定属性（許可す
るアクセスの種類，キャッシュの設定等）に従って，MMUのための変換テーブ
ルを準備し，それを使用するようにMMUを設定する機能を持っている．

この機能は，MMUのセクションテーブルのみを設定する．そのため，設定でき
るアドレスの範囲はセクション単位に限られる．具体的には，変換テーブルに
設定するアドレスの先頭番地およびサイズは，セクションのサイズ（1MB）の
倍数でなければならない．

この機能を使用するには，必要に応じて，次のマクロおよび変数を定義する必
要がある．

(6-5-1-1) USE_ARM_MMU

MMUのための変換テーブルを準備し，それを使用するようにMMUを設定する場合
に，このシンボルをマクロ定義する．

(6-5-1-2) USE_ARM_SSECTION

スーパーセクションを使用する場合に，このシンボルをマクロ定義する．プロ
セッサコアがスーパーセクションをサポートしている場合には，使用した方が
効率が良い．

(6-5-1-3) const ARM_MMU_CONFIG arm_memory_area[]

変換テーブルに設定する各アドレス範囲毎の，先頭の仮想アドレス，物理アド
レス，サイズ，セクション属性（第1レベルディスクリプタの設定値）を含む
構造体（ARM_MMU_CONFIG，定義は以下の通り）の配列．

----------------------------------------
typedef struct arm_mmu_config {
	uint32_t	vaddr;			/* 仮想アドレス */
	uint32_t	paddr;			/* 物理アドレス */
	uint32_t	size;			/* サイズ */
	uint32_t	attr;			/* セクション属性 */
} ARM_MMU_CONFIG;
----------------------------------------

上述の通り，vaddr，paddr，sizeは，1MBの倍数でなければならない．

(6-5-1-4) const uint_t arm_tnum_memory_area

arm_memory_areaの要素数（変換テーブルに設定するアドレス範囲の数）を保
持する変数．通常は，次の定義となる．

----------------------------------------
const uint_t arm_tnum_memory_area
					= sizeof(arm_memory_area) / sizeof(ARM_MMU_CONFIG);
----------------------------------------

なお，MMUの設定をアプリケーションで変更したい場合に対応するために，
arm_memory_areaとarm_tnum_memory_areaの定義には，weak属性を付けること
を推奨する．

6.5.2 その他の設定

(6-5-2-1) TOPPERS_NONUNIFIED_TLB（必要な場合）

ノンユニファイドTLBを持つターゲット（Cortex-A8がこれに該当する）では，
このシンボルをマクロ定義する．

6.6 カーネル実装に関するその他の定義

「ターゲット依存部 ポーティングガイド」の6.10節で説明されている項目の
中で，DEFAULT_ISTKSZはターゲット依存部で定義する必要がある．また，
TARGET_INHATR，TARGET_INTATR，TARGET_MIN_STKSZ，TARGET_MIN_ISTKSZ，
DEFAULT_ISTKは，必要に応じてターゲット依存部で定義する必要がある．その
他はARMコア依存部で定義されているため，ターゲット依存部で定義する必要
はない．

6.7 カーネル実装のターゲット依存部のためのリネーム記述

「ターゲット依存部 ポーティングガイド」の6.12節で説明されているリネー
ム記述は，ターゲット依存部でも対応する必要がある．また，ターゲット依存
部のリネーム記述（target_rename.def）から，コア依存部のリネーム記述を
インクルードする必要がある．具体的には，target_rename.defに「INCLUDE
"core"」の行を含める．

6.8 高分解能タイマドライバとオーバランタイマドライバ

「ターゲット依存部 ポーティングガイド」の6.13節で説明されている高分解
能タイマドライバと，6.14節で説明されているオーバランタイマドライバ（オ
プション）は，ARMコア依存部では対応しておらず，ターゲット依存部で対応
する必要がある．

6.8.1 MPCore依存部を用いる場合

MPCore依存部に含まれるタイマドライバは，プロセッサ毎に持つプライベート
タイマとウォッチドッグ，各プロセッサからアクセスできるグローバルタイマ
を用いて，高分解能タイマとオーバランタイマを実現している．具体的には，
以下の3種類の使用方法をサポートしている．

 (a) プライベートタイマとウォッチドッグで高分解能タイマを実現
 (b) グローバルタイマで高分解能タイマを実現
 (c) ウォッチドッグでオーバランタイマを実現

グローバルタイマは，Cortex-A9 MPCoreのr2p0以降の新しい仕様のものを想定
している．それより古い仕様のグローバルタイマを持つターゲットシステムや，
グローバルタイマを持たないターゲットシステムでは，(b)を使用することは
できない．

(a)～(c)の中で，(b)と(c)は同時に用いることができる．(a)と(c)を同時に用
いることはできない．

MPCore依存部のタイマドライバを使用する場合には，タイマドライバのヘッダ
ファイル（target_time.h）で必要な定義を行った上で，MPCore依存部のタイ
マドライバのヘッダファイル（mpcore_timer.h）をインクルードする．また，
それに合わせて，カーネルAPIのターゲット依存部（target_kernel.h）で必要
な定義を行う必要がある．

グローバルタイマは64ビットであるため，(b)を用いる場合は，HRTCNT型を64
ビットとすることができる（32ビットとすることもできる）．TOPPERS共通定
義のターゲット依存部（target_stddef.h）で，USE_64BIT_HRTCNTをマクロ定
義しても良いし，MakefileのCDEFSを用いてユーザに定義させてもよい．なお，
(a)を用いる場合には，HRTCNT型を64ビットとすることはできない．

以下では，ターゲット依存部で行うべき設定について説明する．

6.8.1.1 プライベートタイマとウォッチドッグで高分解能タイマを実現

プライベートタイマとウォッチドッグを用いて，高分解能タイマを実現する．
具体的には，ウォッチドッグをタイマモードに設定して現在時刻の管理のため
に，プライベートタイマを相対時間割込みの発生のために用いて，高分解能タ
イマを実現している．

プライベートタイマとウォッチドッグのクロック源の周波数が256MHz以下の場
合には，プリスケーラを用いて1MHzのクロックを作り，プライベートタイマと
ウォッチドッグを1MHzで駆動する．この場合には，ターゲット依存部で
mpcore_timer.hをインクルードする前に，次のマクロを定義する必要がある．

(6-8-1-1-1) USE_MPCORE_TMRWDG_HRT	プライベートタイマとウォッチドッグ
									で高分解能タイマを実現することを指
									定
(6-8-1-1-2) MPCORE_TMR_PS_VALUE		プライベートタイマのプリスケーラの
									設定値
(6-8-1-1-3) MPCORE_WDG_PS_VALUE		ウォッチドッグのプリスケーラの設定
									値

プリスケーラの設定値は，分周比（クロック源のMHz単位での周波数）から1を
減じたものに定義する（つまり，MPCORE_TMR_PS_VALUEとMPCORE_WDG_PS_VALUE
には，同じ値を定義することになる）．

この時，target_kernel.h（または，そこからインクルードされるファイル）
で定義すべき高分解能タイマの周期は2^32（TCYC_HRTCNTは定義しない），カ
ウントアップの進み幅（TSTEP_HRTCNT）は1となる．

プライベートタイマとウォッチドッグのクロック源の周波数が256MHzを超える
場合には，プリスケーラで1MHzのクロックを作ることができない．そこで，プ
リスケーラで作ることができる1MHzの倍数の周波数（これを，N MHzとする）
を選び，プライベートタイマとウォッチドッグをN MHzで駆動する．高分解能
タイマは1マイクロ秒に1のペースでカウントアップしなければならないため，
高分解能タイマのタイマ周期（TCYC_HRTCNT）は，2^32/N（小数点以下は切り
捨て）になる．

ここで，Nが2のべき乗でない場合に，高分解能タイマに誤差が出る．これを防
ぐために，高分解能タイマのタイマ周期を作っているウォッチドッグの周期を，
高分解能タイマのタイマ周期のN倍（言い換えると，2^32以下で最も大きいNの
倍数）にする．

この場合には，ターゲット依存部でmpcore_timer.hをインクルードする前に，
上述のマクロに加えて，次のマクロを定義する必要がある．

(6-8-1-1-4) MPCORE_WDG_LR_VALUE		ウォッチドッグのリロード値（Nが2の
									べき乗でない場合のみ）
(6-8-1-1-5) MPCORE_WDG_FREQ			ウォッチドッグの駆動周波数
(6-8-1-1-6) MPCORE_TMR_FREQ			プライベートタイマの駆動周波数

ウォッチドッグのリロード値は，ウォッチドッグの周期から1を減じたもの
（すなわち，TCYC_HRTCNT * N - 1）に定義し，ウォッチドッグとタイマの駆
動周波数は，Nに定義する（つまり，MPCORE_WDG_FREQとMPCORE_TMR_FREQには，
同じ値を定義することになる）．

例えば，プライベートタイマとウォッチドッグを5MHzで駆動する（すなわち，
N＝5）場合には，target_kernel.hにおいて，

----------------------------------------
#define TCYC_HRTCNT				858993459		/* floor(2^32/5) */
----------------------------------------

のマクロ定義を行う．また，ターゲット依存部でmpcore_timer.hをインクルー
ドする前に，

----------------------------------------
#define MPCORE_WDG_LR_VALUE		4294967294		/* TCYC_HRTCNT * 5 - 1 */
#define MPCORE_WDG_FREQ			5
#define MPCORE_TMR_FREQ			5
----------------------------------------

のマクロ定義を行う（他に，USE_MPCORE_TMRWDG_HRT，MPCORE_TMR_PS_VALUE，
MPCORE_WDG_PS_VALUEの定義も必要である）．

(6-8-1-1-7) MPCORE_TMR_CLEAR_INT（オプション）

MPCoreのプライベートタイマとウォッチドッグを用いて高分解能タイマを実現
している場合に，ターゲットによっては，不必要な割込みが頻繁に発生する．
この問題は，プライベートタイマからの割込み要求をクリアする際に，プライ
ベートタイマに対するクリア操作に加えて，割込みコントローラに対しても割
込み要求のクリア操作をすることで回避できる．この回避策を組み込むために
は，MPCORE_TMR_CLEAR_INT()に，以下のように，割込みコントローラに対して
割込み要求のクリア操作をする処理をマクロ定義する．

----------------------------------------
#define MPCORE_TMR_CLEAR_INT()		clear_int(MPCORE_IRQNO_TMR)
----------------------------------------

6.8.1.2 グローバルタイマで高分解能タイマを実現

グローバルタイマを用いて，高分解能タイマを実現する．グローバルタイマは，
Cortex-A9 MPCoreのr2p0以降の新しい仕様のものを想定している．

グローバルタイマのクロック源の周波数が256MHz以下の場合には，プリスケー
ラを用いて1MHzのクロックを作り，グローバルタイマを1MHzで駆動する．この
場合には，ターゲット依存部でmpcore_timer.hをインクルードする前に，次の
マクロを定義する必要がある．

(6-8-1-2-1) USE_MPCORE_GTC_HRT		グローバルタイマで高分解能タイマを
									実現することを指定
(6-8-1-2-2) MPCORE_GTC_PS_VALUE		グローバルタイマのプリスケーラの設
									定値

プリスケーラの設定値は，分周比（クロック源のMHz単位での周波数）から1を
減じたものに定義する．

グローバルタイマのクロック源の周波数が256MHzを超える場合には，プリスケー
ラで1MHzのクロックを作ることができない．そこで，プリスケーラで作ること
ができる1MHzの倍数の周波数（これを，N MHzとする）を選び，プライベート
タイマとウォッチドッグをN MHzで駆動する．この場合には，ターゲット依存
部でmpcore_timer.hをインクルードする前に，上述のマクロに加えて，次のマ
クロを定義する必要がある．

(6-8-1-2-3) MPCORE_GTC_FREQ			グローバルタイマの駆動周波数

いずれの場合も，target_kernel.h（または，そこからインクルードされるファ
イル）で定義すべき高分解能タイマの周期は2^32（TCYC_HRTCNTは定義しない），
カウントアップの進み幅（TSTEP_HRTCNT）は1となる．

(6-8-1-2-4) ARM_CA9_GTC_ERRATA（オプション）

一部のMPCoreのグローバルタイマの実装には，不必要な割込みが発生する不具
合（ARM Cortex-A9 Errata 740657）があることが知られている．そのような
グローバルタイマを持つターゲットシステムでは，ターゲット依存部でこのシ
ンボルをマクロ定義することにより，MPCore依存部のタイマドライバに不具合
対策が組み込まれる．

6.8.1.3 ウォッチドッグでオーバランタイマを実現

ウォッチドッグをタイマモードに設定して，オーバランタイマを実現する．

ウォッチドッグのクロック源の周波数が256MHz以下の場合には，プリスケーラ
を用いて1MHzのクロックを作り，ウォッチドッグを1MHzで駆動する．この場合
には，ターゲット依存部でmpcore_timer.hをインクルードする前に，次のマク
ロを定義する必要がある．

(6-8-1-3-1) USE_MPCORE_WDG_OVRTIMER	ウォッチドッグでオーバランタイマを
									実現することを指定
(6-8-1-3-2) MPCORE_WDG_PS_VALUE		ウォッチドッグのプリスケーラの設定
									値

プリスケーラの設定値は，分周比（クロック源のMHz単位での周波数）から1を
減じたものに定義する．

ウォッチドッグのクロック源の周波数が256MHzを超える場合には，プリスケー
ラで1MHzのクロックを作ることができない．そこで，プリスケーラで作ること
ができる1MHzの倍数の周波数（これを，N MHzとする）を選び，ウォッチドッ
グをN MHzで駆動する．この時，target_kernel.h（または，そこからインクルー
ドされるファイル）で定義すべきオーバランハンドラの残りプロセッサ時間に
指定できる最大値（TMAX_OVRTIM）は，2^32/N（小数点以下は切り捨て）にな
る．また，ターゲット依存部でmpcore_timer.hをインクルードする前に，上述
のマクロに加えて，次のマクロを定義する必要がある．

(6-8-1-3-3) MPCORE_WDG_FREQ			ウォッチドッグの駆動周波数

6.9 FPUサポートに関する定義

ARM依存部におけるFPUサポートに関しては，「ARM依存部 ユーザーズマニュア
ル」を参照すること．

(6-9-1) ASM_ARM_FPU_TYPE			FPUの種類

使用するFPUの種類に定義する．アセンブラのコード中の.fpuディレクティブ
で使用する．

(6-9-2) USE_ARM_FPU_ALWAYS			FPUを常に使用する
(6-9-3) USE_ARM_FPU_SELECTIVE		指定したタスクのみがFPUを使用する
(6-9-4) USE_ARM_FPU_D32				コンテキストに32個のレジスタを含める

FPUの使用方法をターゲット依存部で固定する場合には，これらのマクロをター
ゲット依存部で定義する．


７．コンフィギュレータ設定ファイルのターゲット依存部

7.1 値取得シンボルテーブル

ARM依存部では，コア依存部で必要となるシンボルを記述したファイルを用意
している（core_sym.def）．また，Makefile.coreには，core_sym.defをコン
フィギュレータに読み込ませるための記述が含まれている．

ターゲット依存部で必要となるシンボルがある場合には，それを記述したファ
イルを用意し，それをコンフィギュレータに読み込ませるための記述が含める．

7.2 パス2の生成スクリプトのターゲット依存部

「ターゲット依存部 ポーティングガイド」の7.2節で説明されている項目の中
で，$INTNO_VALIDと$INHNO_VALIDはターゲット依存部で定義する必要がある．
また，$INTNO_CREISR_VALID，$INHNO_CREISR_VALID，AllocStack，
TargetCheckCfgInt，TargetCheckDefInh，TargetCheckCreIsrは，必要に応じ
てターゲット依存部で定義する必要がある．その他はARMコア依存部で定義さ
れているため，ターゲット依存部で定義する必要はない．

7.3 パス3の生成スクリプトのターゲット依存部

「ターゲット依存部 ポーティングガイド」の7.3節で説明されている項目の中
で，$lmaListは，必要に応じてターゲット依存部で定義する必要がある．その
他は，ターゲット依存部で定義する必要はない．

7.4 cfg1_out.cのリンクに必要なスタブの定義ファイル

リンカスクリプトにも依存するが，ARMコア依存部で用意されているスタート
アップモジュールを用いる場合には，「ターゲット依存部 ポーティングガイ
ド」の7.4節で説明されているcfg1_out.cをリンクするために必要なスタブの
定義ファイル（target_cfg1_out.h）は，ARM依存部のcore_cfg1_out.hをイン
クルードするだけでよい．


８．システムサービス等のターゲット依存部

「ターゲット依存部 ポーティングガイド」の８章で説明されているシステム
サービス等のターゲット依存部は，基本的には，ターゲット依存部で対応する
必要がある．

ただし，ARMコア依存部で，システムサービスのコア依存部（core_syssvc.h）
と，サンプルプログラムとテストプログラムのコア依存部（core_test.h）を
用意している．適切なシンボルをマクロ定義した上で，ターゲット依存部から
これらをインクルードすることで，以下の設定を利用することができる．

8.1 システムサービスのコア依存部

実行時間分布集計サービスによる性能評価を，パフォーマンスモニタを用いて
行うための設定（「ターゲット依存部 ポーティングガイド」の8.5.2節で説明
されている設定）を含んでいる．

8.2 サンプルプログラムとテストプログラムのコア依存部

サンプルプログラムおよびテストプログラムで用いるCPU例外を，各種の原因
で発生させるための設定（「ターゲット依存部 ポーティングガイド」の8.6節
のCPUEXC1，RAISE_CPU_EXCEPTION，PREPARE_RETURN_CPUEXCの定義）を含んで
いる．

8.3 ARM PrimCell UART（PL011）用 簡易デバイスドライバ

ターゲットシステムが，ARM PrimCell UART（PL011）を用いている場合には，
シリアルインタフェースドライバのターゲット依存部として，ARM依存部で用
意しているARM PrimCell UART（PL011）用 簡易SIOドライバを用いることがで
きる．


９．その他

「ターゲット依存部 ポーティングガイド」の９章で説明されているその他の
事項は，基本的には，ターゲット依存部で対応する必要がある．

ただし，ターゲット依存部のユーザーズマニュアルを作成する際に，「ARM依
存部 ユーザーズマニュアル」に記載されている事項については，そちらを参
照することで記述を省くことができる．

以上
