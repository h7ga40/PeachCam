
		TOPPERS/ASP3カーネル
		ARMコア依存部 設計メモ

		対応バージョン: Release 3.7.1
		最終更新: 2023年4月11日

----------------------------------------------------------------------
 TOPPERS/ASP Kernel
     Toyohashi Open Platform for Embedded Real-Time Systems/
     Advanced Standard Profile Kernel

 Copyright (C) 2014-2023 by Embedded and Real-Time Systems Laboratory
             Graduate School of Information Science, Nagoya Univ., JAPAN
 
 上記著作権者は，以下の(1)～(4)の条件を満たす場合に限り，本ソフトウェ
 ア（本ソフトウェアを改変したものを含む．以下同じ）を使用・複製・改
 変・再配布（以下，利用と呼ぶ）することを無償で許諾する．
 (1) 本ソフトウェアをソースコードの形で利用する場合には，上記の著作
     権表示，この利用条件および下記の無保証規定が，そのままの形でソー
     スコード中に含まれていること．
 (2) 本ソフトウェアを，ライブラリ形式など，他のソフトウェア開発に使
     用できる形で再配布する場合には，再配布に伴うドキュメント（利用
     者マニュアルなど）に，上記の著作権表示，この利用条件および下記
     の無保証規定を掲載すること．
 (3) 本ソフトウェアを，機器に組み込むなど，他のソフトウェア開発に使
     用できない形で再配布する場合には，次のいずれかの条件を満たすこ
     と．
   (a) 再配布に伴うドキュメント（利用者マニュアルなど）に，上記の著
       作権表示，この利用条件および下記の無保証規定を掲載すること．
   (b) 再配布の形態を，別に定める方法によって，TOPPERSプロジェクトに
       報告すること．
 (4) 本ソフトウェアの利用により直接的または間接的に生じるいかなる損
     害からも，上記著作権者およびTOPPERSプロジェクトを免責すること．
     また，本ソフトウェアのユーザまたはエンドユーザからのいかなる理
     由に基づく請求からも，上記著作権者およびTOPPERSプロジェクトを
     免責すること．
 
 本ソフトウェアは，無保証で提供されているものである．上記著作権者お
 よびTOPPERSプロジェクトは，本ソフトウェアに関して，特定の使用目的
 に対する適合性も含めて，いかなる保証も行わない．また，本ソフトウェ
 アの利用により直接的または間接的に生じたいかなる損害に関しても，そ
 の責任を負わない．
 
 $Id: arm_design.txt 1809 2023-04-11 07:45:05Z ertl-hiro $
----------------------------------------------------------------------

○目次

・略号
・参考文献
・ARMコア依存部の位置づけ
	- Thumb命令の扱い
・システム状態の管理
	- プロセッサモード
	- カーネル管理外の割込み
	- 全割込みロック状態の管理
	- コンテキストの管理
	- CPUロック状態の管理
	- 割込み優先度マスクの管理
	- 割込み要求禁止フラグの管理
	- 割込みに関するその他の操作
	- CPSR（Program Status Register）の設定値
・例外（割込みハンドラおよびCPU例外ハンドラ）の出入口
	- ARMv6より前のプロセッサの場合
	- ARMv6以降のプロセッサの場合
	- スタックポインタの調整
・割込みハンドラの出入口処理
・CPU例外ハンドラの出入口処理
	- スタックポインタが不正の場合の対策
・FPUのサポート
	- FPUサポートの方針
	- FPUレジスタの整理
	- FPUを常に使用する実装
	- FPUを使用する処理を限定する実装
	- ABIを指定するコンパイルオプション（調査結果）
	- コンパイルオプションによるFPU命令の生成（調査結果）
	- FPUを使用する処理を限定する場合のコンパイルオプション

○略号

ABI			Application Binary Interface
CPSR		Current Program Status Register
FIQ			Fast Interrupt Request
GIC			Generic Interrupt Controller
IRQ			Interrupt Request

○参考文献

[1] TOPPERSプロジェクト 設計メモ「ARMのアーキテクチャに関するメモ」．

○ARMコア依存部の位置づけ

ARMコア依存部は，カーネルのターゲット依存部の中で，ARMv4，ARMv5，ARMv6，
ARMv7-A，ARMv7-Rに準拠したプロセッサコアを持つターゲットシステム（チッ
プ）に共通に使用できる部分である．ただし，これに該当するすべてのARMコア
に対応できているわけではない．新しいチップにポーティングする際には，コ
ア依存部に何らかの修正が必要になることも多いと思われる．

ARMコアのプロセッサコア略称を"arm"とする．GNU開発環境向けのARMコア依存
部を置くディレクトリはarch/arm_gcc/commonとなる．

ARMの場合，割込みコントローラはコアの外にあることから，割込みコントロー
ラに依存する部分はARMコア依存部に含めないことを原則とするが，多くのチッ
プに採用されている割込みコントローラであるGIC（ARM Generic Interrupt
Controller）に依存する部分（GIC依存部）は，ARMコア依存部のディレクトリ
に置いている．GIC依存部の設計については，「GIC依存部 設計メモ」を参照す
ること．

なお，ARMコア依存部は，ARMアーキテクチャのバージョン番号（4～7のいずれ
か）が，__TARGET_ARCH_ARMにマクロ定義されているものとして記述してある．

●Thumbモードの扱い

アプリケーションプログラムとカーネルのC言語で記述された部分は，Thumbモー
ド向けにコンパイルしても動作するようにする．それに対して，カーネルのア
センブリ言語記述の部分は，ARM命令で記述し，Thumbモードで実行することは
考えない．

○システム状態の管理

●プロセッサモード

ASP3カーネルのARMコア依存部では，アプリケーションプログラムとカーネルの
大部分を，スーパバイザモードで実行する．例外の入口でそれぞれのプロセッ
サモードに切り換わるが，入口処理の中でスーパバイザモードに戻すため，あ
くまでカーネルの内部で一時的に他のモードを使うに過ぎない．

割込み処理の実行にIRQモードを使わないのは，次の理由である．IRQモードで
実行中に割込みが発生すると，lrレジスタに戻り番地が格納される．そのため，
割込み処理をIRQモードを実行すると，多重割込みによりlrレジスタの内容が失
われるため，多重割込みを許可することができない．

アプリケーションプログラムとカーネルの大部分の実行にシステムモードを使
わない理由は，以下の通りである．

(1) ARMv6より前（ARMv5以前）のプロセッサでは，例外からの復帰を，

	ldmfd	sp!, {<復帰すべきレジスタのリスト>, pc}^

の命令で行う．この命令は，例外モードでのみ使用することができ，システム
モードでは使用できない（システムモードにはSPSRがないため，CPSRを復帰で
きない）．そのため，割込みハンドラやCPU例外ハンドラをシステムモードで実
行すると，例外からのリターン時に，余計なプロセッサモード切換えとそれに
伴うスタック操作が必要になり，効率が悪い．

ARMv6以降のプロセッサでは，例外からの復帰のためにrfe命令を持っているが，
rfe命令にはシステムモードでは使用できないという制約がないために，このこ
とは当てはまらない．

(2) 保護機能対応カーネルにおいては，例外の入口で，ユーザスタックからシ
ステムスタックに切り換える処理が必要であるが，アプリケーションプログラ
ムの非特権モードで実行すべき部分をユーザモードで，アプリケーションプロ
グラムの特権モードで実行すべき部分とカーネルの大部分をスーパバイザモー
ドを実行すれば，スタックの切換えがハードウェアで行われ，効率的である．

逆に，アプリケーションプログラムとカーネルの大部分をシステムモードで実
行するメリットとして，以下を挙げることができる．

・スーパバイザモードで実行中にsvc命令を発行すると，lrレジスタに戻り番地
　が格納される．lrが壊れる想定でsvc命令を呼び出せばよいが，プログラムに
　パッチを当てる目的でsvc命令を使う場合など，lrを保存／復帰する余地がな
　い場合には，スーパバイザモードで実行しているとうまく実装できない．

保護機能対応でないASP3カーネルで，ARMv6以降のプロセッサを使用する場合に
は，アプリケーションプログラムとカーネルの大部分をシステムモードで実行
するように修正するのは容易である．具体的には，core_support.Sとstart.S内
の約20箇所程度のCPSR_SVC_MODEを，CPSR_SYS_MODEに書き換えればよい．

●カーネル管理外の割込み

ARMコア依存部の標準では，IRQをカーネル管理の割込み，FIQをカーネル管理外
の割込みと扱う．このようにするのが，最もシンプルで性能が良いためである．

ただし，SafeGのセキュアモードでASP3カーネルを動作させる場合には，FIQを
カーネル管理の割込みとして扱い，カーネル管理外の割込みはサポートしない．
IRQは，ノンセキュアモードで動作するOSが使用する．この設定にする場合には，
TOPPERS_SAFEG_SECUREをマクロ定義する．

●全割込みロック状態の管理

全割込みロック状態では，FIQ・IRQともマスクする．具外的には，CPSR中のFビッ
ト（FIQ禁止）とIビット（IRQ禁止）をセットする．

●コンテキストの管理

実行中のコンテキストをプロセッサモードで判断することができないため，例
外（割込みハンドラおよびCPU例外ハンドラ）のネスト段数を変数（これを，例
外ネストカウントと呼ぶ）で管理し，例外ネストカウントが0の時にタスクコン
テキスト，0より大きい場合に非タスクコンテキストであると判断する．

●CPUロック状態の管理

CPUロック状態では，IRQをマスクする．具外的には，CPSR中のIビット（IRQ禁
止）をセットする．全割込みロック状態とCPUロック状態を区別できる必要はな
いことから，CPSR中のIビットが立っていれば，CPUロック状態であると判断す
る．

TOPPERS_SAFEG_SECUREがマクロ定義されている場合には，CPUロック状態では，
FIQをマスクする．IRQは常にマスクするため，FIQ・IRQともマスクすることに
なる．CPSR中のFビットが立っていれば，CPUロック状態であると判断する．

●割込み優先度マスクの管理

割込み優先度マスクの管理は，割込みコントローラによって行う．そのため，
ARM依存部には含めない．

GICの場合には，GICC_PMR（Interrupt Priority Mask Register）により，割込
み優先度マスクを管理する．

●割込み要求禁止フラグの管理

割込み要求禁止フラグの管理は，割込みコントローラによって行う．そのため，
ARM依存部には含めない．

GICの場合には，GICD_ISENABLEn（Interrupt Set-Enable Registers）と
GICD_ICENABLERn（Interrupt Clear-Enable Registers）によって，セット／ク
リアする．

●割込みに関するその他の操作

割込みに関するその他の操作は，割込みコントローラによって実現する．その
ため，ARM依存部には含めない．

GICの場合には，割込み要求のクリアとプローブは，GICD_ICPENDRn（Interrupt
Clear-Pending Registers）とGICD_ISPENDRn（Interrupt Set-Pending
Registers）によって実現する．

●CPSR（Program Status Register）の設定値

CPUロック・全割込みロック解除状態，CPUロック状態，全割込ロック状態とす
るCPSRの設定値を，以下のように定義しておく．

#define CPSR_UNLOCK			UINT_C(0x00)
#define CPSR_CPULOCK		CPSR_IRQ_BIT
#define CPSR_INTLOCK		CPSR_FIQ_IRQ_BIT

TOPPERS_SAFEG_SECUREがマクロ定義されている場合には，以下のように定義す
る．

#define CPSR_UNLOCK			CPSR_IRQ_BIT
#define CPSR_CPULOCK		CPSR_FIQ_IRQ_BIT
#define CPSR_INTLOCK		CPSR_FIQ_IRQ_BIT

ここで，CPSR_IRQ_BITとCPSR_FIQ_BITは，それぞれIRQとFIQをマスクする場合
のCPSRの値，CPSR_FIQ_IRQ_BITは，FIQ・IRQともマスクする場合のCPSRの値で
あり，以下のように定義しておく．

#define CPSR_IRQ_BIT		UINT_C(0x80)
#define CPSR_FIQ_BIT		UINT_C(0x40)
#define CPSR_FIQ_IRQ_BIT	(CPSR_FIQ_BIT|CPSR_IRQ_BIT)

○例外（割込みハンドラおよびCPU例外ハンドラ）の出入口

SRS命令とRFE命令を持つARMv6以降と，それより前のプロセッサでは，例外の出
入口（割込みハンドラおよびCPU例外ハンドラの出入口処理の最初と最後の部分）
の最適なコードが異なる．

●ARMv6より前のプロセッサの場合

アーキテクチャの想定では，例外からの復帰を，

	ldmfd	sp!, {<復帰すべきレジスタのリスト>, pc}^

の命令で行う．この時点で，戻り番地がスタックの最後（最も大きい番地）に
保存されており，戻り先のCPSRがこのモードのSPSRに置かれていることが必要
である．

例外の出入口処理で，すべてのスクラッチレジスタを保存／復帰することにす
ると，上の命令の<復帰すべきレジスタのリスト>には，すべてのスクラッチレ
ジスタのリストを記述する．また，例外からのリターンでモードが変わらない
（どちらもスーパバイザモードである）ため，復帰するレジスタに，lrも加え
ておくことが必要である．

具体的には，例外の出口は，次のようなコードとなる．

----------------------------------------
	/*
	 *  この時点ではスーパバイザモードになっている．
	 */
	pop		{r0}						/* 戻り先のcpsrをspsrに復帰 */
	msr		spsr_cxsf, r0
	ldmfd	sp!, {r0-r5,r12,lr,pc}^		/* 例外処理からの復帰 */
----------------------------------------

ここで，スクラッチレジスタに加えてr4とr5も復帰しているのは，例外の出入
口処理でスクラッチレジスタ以外に使えるレジスタとして，r4とr5を確保する
ためである（実際には，r4だけが使えれば十分であるが，スタックポインタを
8バイト境界にアラインするためにr5も保存／復帰している）．

この出口を実行する時点で，スタックは次のようになっている必要がある（レ
ジスタはいずれもCPU例外発生時の値を示す．例えば，CPSRはCPU例外発生時の
CPSRを示す）．

	+----------------+ <- sp
	|      cpsr      |
	+----------------+ <- sp+0x04
	|       r0       |
	+----------------+ <- sp+0x08
	|       r1       |
	+----------------+ <- sp+0x0c
	|       r2       |
	+----------------+ <- sp+0x10
	|       r3       |
	+----------------+ <- sp+0x14
	|       r4       |
	+----------------+ <- sp+0x18
	|       r5       |
	+----------------+ <- sp+0x1c
	|       r12      |
	+----------------+ <- sp+0x20
	|       lr       |
	+----------------+ <- sp+0x24
	|    戻り番地    |
	+----------------+ <- sp+0x28

これに対応する例外の入口は，次のコードとなる（IRQの場合）．

----------------------------------------
	/* 
	 *  スーパバイザモードに切り換え，スクラッチレジスタを保存する．
	 */
	msr		cpsr_c, #(CPSR_SVC_MODE AOR CPSR_IRQ_BIT)
	push	{r0-r5,r12,lr,pc}		/* pcはスペース確保のため */		(*1)

	/*
	 *  IRQモードに戻して，戻り番地（lr-4）と戻り先のcpsr（spsr）を取
	 *  得する．
	 */
	msr		cpsr_c, #(CPSR_IRQ_MODE AOR CPSR_IRQ_BIT)
	sub		r2, lr, #4
	mrs		r1, spsr

	/*
	 *  スーパバイザモードに切り換え，戻り番地と戻り先のcpsrを保存する．
	 */
	msr		cpsr_c, #(CPSR_SVC_MODE AOR CPSR_IRQ_BIT)
	str		r2, [sp,#0x20]			/* 戻り番地をスタックに保存 */		(*2)
	push	{r1}					/* 戻り先のcpsrをスタックに保存 */
----------------------------------------

(*1)でpcを保存するのは，戻り番地を保存すべきスペースを確保するためであ
り，その時点で保存するpcの値は使わない．(*2)で，確保したスペースに戻り
番地を格納する．格納先を[sp,#0x20]とするのは，この時点ではspは上の図の
（sp+0x04）を指しており，戻り番地は（sp+0x24）に格納したいためである．

例外を受け付けるとIビットをセットするため，例外の入口が実行される時点で，
CPSRのIビットはセットされている．IRQの場合，IRQが受け付けられたというこ
とは，受付前の時点ではIビットはクリアされていたはずであるため，Fビット
はクリアされている（Iビットがセットされており，Fビットがクリアされてい
る状況は作らないため）．よって，上記のコードで，IビットとFビットは変化
しない．

IRQ以外の例外（CPU例外ハンドラ）の出入口においては，上記のコードに対し
て，次の修正を加える．

・Iビットだけではなく，Fビットもセットする．具体的には，3箇所にある
　CPSR_IRQ_BITを，CPSR_FIQ_IRQ_BITに置き換える．

・戻り番地を取得する時に，lrから4を減算しない（実際に戻るべき番地になっ
　ているとは限らない）．

・戻り番地とspsrを取得する時に，IRQモードではなく，そのCPU例外で遷移す
　るモードに戻す（スーパバイザコールの場合は，戻す必要がない）．

IビットだけでなくFビットもセットするのは，(1) FIQを受け付けるとFビット
もセットされる，(2) その他の例外はFビットがセットされている状態でも受け
付けられる，の2つの理由からである．ただし，Fビットがクリアされている時
に発生した（FIQ以外の）例外では，この処理によりFビットがセットされるこ
とになり，カーネル管理外の割込みがマスクされる期間が長くなるが，CPU例外
ハンドラを呼び出すまでの短時間なので，許容することにする．

3つめの処理（スーパバイザモードに切り換えと，戻り番地とspsrの保存）は，
（IRQ以外の）すべての例外で共通であるため，exc_handler_1の先頭で実施す
ることもできるが，ARMv6以降のプロセッサの場合との共通化のために，例外毎
に個別に実施する．

●ARMv6以降のプロセッサの場合

例外からの復帰にrfe命令を用いると，例外の出口は，次のようなコードとなる．

----------------------------------------
	pop		{r0-r5,r12,lr}
	rfefd	sp!
----------------------------------------

ここで，スクラッチレジスタに加えてr4とr5も復帰しているのは，例外の出入
口処理でスクラッチレジスタ以外に使えるレジスタとして，r4とr5を確保する
ためである（実際には，r4だけが使えれば十分であるが，スタックポインタを
8バイト境界にアラインするためにr5も保存／復帰している）．

この出口を実行する時点で，スタックは次のようになっている必要がある（レ
ジスタはいずれもCPU例外発生時の値を示す．例えば，CPSRはCPU例外発生時の
CPSRを示す）．

	+----------------+ <- sp
	|       r0       |
	+----------------+ <- sp+0x04
	|       r1       |
	+----------------+ <- sp+0x08
	|       r2       |
	+----------------+ <- sp+0x0c
	|       r3       |
	+----------------+ <- sp+0x10
	|       r4       |
	+----------------+ <- sp+0x14
	|       r5       |
	+----------------+ <- sp+0x18
	|       r12      |
	+----------------+ <- sp+0x1c
	|       lr       |
	+----------------+ <- sp+0x20
	|    戻り番地    |
	+----------------+ <- sp+0x24
	|      cpsr      |
	+----------------+ <- sp+0x28

これに対応する例外の入口は，次のようなコードとなる（IRQの場合）．

----------------------------------------
	/* 
	 *  戻り番地（lr）と戻り先のcpsr（spsr）をスーパバイザモードのスタッ
	 *  クに保存する．
	 */
	sub		lr, lr, #4				/* 戻り番地の算出 */
	srsfd	#CPSR_SVC_MODE!

	/*
	 *  スーパバイザモードに切り換え，スクラッチレジスタを保存する．
	 */
	cps		#CPSR_SVC_MODE
	push	{r0-r5,r12,lr}
----------------------------------------

IRQ以外の例外（CPU例外ハンドラ）の出入口においては，上記のコードに対し
て，次の修正を加える．

・戻り番地の算出のためにlrから4を減算しない（実際に戻るべき番地になって
　いるとは限らない）．

後半の処理（スーパバイザモードへの切換えとスクラッチレジスタの保存）は
共通だが，この直後でCPU例外ハンドラ番号を格納するためにr4を使うため，
exc_handler_1の方へ移動できない．

なお，ARMv6より前のプロセッサの場合と異なり，IRQ以外の例外（CPU例外ハ
ンドラ）の出入口において，Fビットはセットしない．

●スタックポインタの調整

ARMでは，外部インタフェースにおいてスタックポインタを8バイト境界にアラ
インさせなければならないが，あくまで外部インタフェースにおける要求事項
であるため，例外発生時にそれが満たされているとは限らない．そこで，割込
みハンドラおよびCPU例外ハンドラの入口で，スタックポインタが8バイト境界
にアラインしていない場合には，8バイト境界にアラインするようにスタック
ポインタを調整する．また，出口処理でスタックポインタを元に戻せるように，
調整量を保存する．具体的なコードは次の通り．

----------------------------------------
	/*
	 *  スタックポインタの調整
	 */
	and		r1, sp, #4
	sub		sp, sp, r1
	push	{r0,r1}					/* r0はスペース確保のため */
----------------------------------------

このコードで，r1には，スタックポインタが8バイト境界にアラインしている
場合には0が，アラインしていない場合には4が入る（スタックポインタは4バ
イト境界には必ずアラインされている）．スタックポインタをr1の分調整し，
r1をスタックに保存する．

割込みハンドラおよびCPU例外ハンドラの出口では，スタックポインタの調整
量をスタックから復帰し，スタックポインタを元に戻す．具体的なコードは次
の通り．

----------------------------------------
	pop		{r0,r1}					/* スタックポインタの調整を元に戻す */
	add		sp, sp, r1
----------------------------------------

○割込みハンドラの出入口処理

ASP3カーネル ポーティングガイドに従って，割込みハンドラの出入口処理の
実装方法を検討していく．

----------------------------------------
void
<割込みの出入口処理>(void)
{
	少なくともカーネル管理の割込みを禁止した状態にする … (*d)
	スクラッチレジスタをスタックに保存する … (*p)
----------------------------------------

ARMコアは，例外を受け付けると，CPSR中のIビットをセットして割込みを禁止
するため，(*d)の処理は必要ない．スクラッチレジスタの保存は，例外の入口
で実装済みである．

----------------------------------------
	if (割込みがタスクコンテキストで発生) {
----------------------------------------

まず，例外ネストカウントをインクリメントする．インクリメント後の値が1で
ない場合には，非タスクコンテキストでの割込み発生であるため，この後の{}
内の処理をスキップする（irq_handler_1に分岐）．

----------------------------------------
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_stop();				/* オーバランタイマの停止 */ … (*e)
#endif /* TOPPERS_SUPPORT_OVRHDR */
----------------------------------------

TOPPERS_SUPPORT_OVRHDRが定義されている場合には，ovrtimer_stopを呼び出
す．

----------------------------------------
		スタックを非タスクコンテキスト用のスタックに切り換え，
								非タスクコンテキストに切り換える
	}
----------------------------------------

スタックを非タスクコンテキスト用のスタックに切り換え，切り換え前のスタッ
クポインタを切り換え後のスタック上に保存する．これらの処理の後に，
irq_handler_1ラベルを置く．

----------------------------------------
	割込み優先度マスクを，受け付けた割込みの割込み優先度に設定する
	割込みハンドラの入口で必要なIRCの操作を行う（割込み要求ラインがエッ
				ジトリガである場合のトリガされた割込み要求のクリアなど）
----------------------------------------

割込み優先度マスクの管理は，チップ依存の割込みコントローラによって行う
必要があるため，これらの処理は，チップ依存部のirc_begin_intで行う．す
なわち，irc_begin_intは，割込み優先度マスクを受け付けた割込み要求の割
込み優先度に設定し，割込みハンドラの入口で必要なIRCの操作を行う．また
irc_begin_intは，割込み番号（0から始まる番号で，割込みハンドラ番号と一
致させる）を返すようにする．スプリアス割込みの場合には，irc_begin_int
は割込み番号の最大値より大きい値を返すものとし，その場合には，割込みハ
ンドラの呼出し処理をスキップする（irq_handler_2に分岐）．

----------------------------------------
	CPUロック解除状態にする（受け付けた割込みよりも優先度の高い割込みを
												受け付けるようにする）
----------------------------------------

CPUロック解除状態にするために，CPSR中のFビットとIビット（ただし，
TOPPERS_SAFEG_SECUREの場合は，Fビットのみ）をクリアして，割込みを許可
する．

----------------------------------------
#ifdef LOG_INH_ENTER
	log_inh_enter(割込みハンドラ番号);
#endif /* LOG_INH_ENTER */
----------------------------------------

LOG_INH_ENTERが定義されている場合には，割込みハンドラ番号をパラメータ
として，log_inh_enterを呼び出す．

----------------------------------------
	割込みハンドラを呼び出す
----------------------------------------

割込みハンドラテーブル（inh_table）から割込みハンドラの番地を取り出して
呼び出す．

----------------------------------------
#ifdef LOG_INH_LEAVE
	log_inh_leave(割込みハンドラ番号);
#endif /* LOG_INH_LEAVE */
----------------------------------------

LOG_INH_LEAVEが定義されている場合には，割込みハンドラ番号をパラメータ
として，log_inh_leaveを呼び出す．

----------------------------------------
	少なくともカーネル管理の割込みを禁止した状態にする
----------------------------------------

カーネル管理の割込みを禁止するために，CPSR中のIビット（ただし，
TOPPERS_SAFEG_SECUREの場合は，Fビットも）をセットする．この処理の後に，
irq_handler_2ラベルを置く．

----------------------------------------
	割込みハンドラの出口で必要なIRCの操作を行う（IRCに対する割込み処理
														の終了通知など）
	割込み優先度マスクを，割込みを受け付ける前の値に戻す … (*f)
----------------------------------------

これらの処理は，チップ依存部のirc_end_intで行う．すなわち，irc_end_int
は，割込みハンドラの出口で必要なIRCの操作を行い，割込み優先度マスクを
割込み処理前の状態に戻す．

コア依存部からは，irc_end_intにパラメータを渡さないため，irc_end_intの
中で必要な情報（例えば，割込み番号）は，irc_begin_intでスタックの先頭に
保存しておく必要がある．これに用いるために，スタックの先頭に1ワードの空
き領域を設けている．

irc_end_intで必要な情報が1ワードで不足する場合には，irc_begin_intでスタッ
クに積み，irc_end_intでスタックから取り出す．これを可能にするために，
irc_begin_intが呼び出されたら，irc_end_intも必ず呼び出されるようにして
おく．スプリアス割込みの場合にも，irc_end_intを呼び出すようにしている．
サブルーチン（irc_begin_int）の中でスタックに積み増すのは，一般には採用
しないプログラミング技法であるが，irc_begin_intからirc_end_intに渡す情
報は，チップ依存部によって異なること，ARMでは戻り番地をlrに保存するため
スタックに積み増すのが容易であることから，この方法を採用することにした．

----------------------------------------
	if (割込みがタスクコンテキストで発生) {
----------------------------------------

例外ネストカウントをデクリメントする．デクリメント後の値が0でない場合
には，非タスクコンテキストでの割込み発生であるため，{}内の処理をスキッ
プする（irq_handler_5に分岐）．

----------------------------------------
		スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
																… (*g)
----------------------------------------

タスクコンテキストのスタックポインタは，この時点で，スタックの先頭に保
存されているため，スタックの先頭を取り出して，スタックポインタに設定す
る．

----------------------------------------
		if (p_runtsk == NULL) {
----------------------------------------

p_runtskがNULLでなければ，この後の{}内の処理をスキップする
（irq_handler_3に分岐）．

----------------------------------------
			タスクのスタックに保存したスクラッチレジスタ等を捨てる … (*o)
----------------------------------------

ここでは，スタックに保存したスクラッチレジスタを捨てる．また，スタック
ポインタの調整を元に戻すことも必要である．

----------------------------------------
			CPUロック状態にする … (*h)
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
			dispatcher_0に分岐する
		}
----------------------------------------

(*h)の処理は，irc_end_intを呼び出す前に行ったカーネル管理の割込みを禁
止する処理で十分であるため，ここでは行わない．(*i)については，
irc_end_intで割込み優先度マスクを割込み処理前の状態に戻すことで，満た
されているはずである．そこで，単にdispatcher_0に分岐すればよい．

----------------------------------------
		if (p_runtsk != p_schedtsk) {
----------------------------------------

この処理の前に，irq_handler_3ラベルを置く．p_runtskとp_schedtskが一致
する時は，irq_handler_4へ分岐する．

----------------------------------------
			CPUロック状態にする … (*h)
			割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
----------------------------------------

(*h)の処理は，irc_end_intを呼び出す前に行ったカーネル管理の割込みを禁
止する処理で十分であるため，ここでは行わない．(*i)については，
irc_end_intで割込み優先度マスクを割込み処理前の状態に戻すことで，満た
されているはずである．

----------------------------------------
			スクラッチレジスタを除くすべてのレジスタをスタックに保存する
			スタックポインタを自タスク（p_runtsk）のTCBに保存する
			ret_int_rを，実行再開番地として自タスクのTCBに保存する … (*a)
			dispatcherに分岐する

		  ret_int_r:
			スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
		}
----------------------------------------

この辺りは素直に実装できる．

----------------------------------------
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
----------------------------------------

この処理の前に，irq_handler_4のラベルを置く．TOPPERS_SUPPORT_OVRHDRが
定義されている場合には，ovrtimer_startを呼び出す．

----------------------------------------
	}
	割込み処理からのリターンにより，CPUロック解除状態に戻るように準備する
	スクラッチレジスタをスタックから復帰する … (*p)
	割込み処理からのリターン
}
----------------------------------------

これらの処理の前に，irq_handler_5のラベルを置く．これらの処理は，例外か
らの出口で行う．

○CPU例外ハンドラの出入口処理

ASP3カーネル ポーティングガイドに従って，CPU例外ハンドラの出入口処理の
実装方法を検討していく．

----------------------------------------
void
<CPU例外の出入口処理>(void)
{
	スクラッチレジスタをスタックに保存する … (*p)
----------------------------------------

この処理は，例外の入口で実装済みである．

----------------------------------------
	CPU例外が発生した状況を判断するための追加情報をスタックに保存する … (*j)
	この時点でのスタックポインタ±nを，CPU例外の情報を記憶している領域の
										先頭番地とする（必要なら保存する）
----------------------------------------

exc_sense_intmaskを実現するために，CPU例外が発生した時点でのコンテキス
トと割込み優先度マスク（割込み優先度マスクは，CPU例外がタスクコンテキ
ストで発生した場合のみ）が必要となる．そこで，現在の例外ネストカウント
と割込み優先度マスク（CPU例外の発生で割込み優先度マスクが変わることは
ないため，これで良い）をスタックに保存する．ここでスタック上に保存する
割込み優先度マスクは，CPU例外がタスクコンテキストで発生した場合にのみ
使用するので，非タスクコンテキストで発生した場合には正しい値でなくても
良い．割込み優先度マスクは，チップ依存部のirc_get_intpriを呼び出すこと
で取得する．

また，CPU例外の情報を記憶している領域の先頭番地として，この時点でのス
タックポインタを，レジスタに保存しておく．

----------------------------------------
	if (カーネル管理外のCPU例外) {
----------------------------------------

カーネル管理外のCPU例外は，カーネル実行中，全割込みロック状態，CPUロッ
ク状態，カーネル管理外の割込みハンドラ実行中に発生したCPU例外である．
ARMコアの場合は，戻り先のCPSRのIビットかFビットのいずれかがセットされて
いるなら，これに該当する．

そこで，例外フレームから戻り先のCPSRを取り出し，IビットかFビットのいず
れかがセットされている場合には，カーネル管理外のCPU例外の出入口処理
（nk_exc_handler_1）に分岐する．

----------------------------------------
		if (CPU例外がタスクコンテキストで発生) {
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える … (*k)
		}
----------------------------------------

カーネル管理外のCPU例外の出入口処理（nk_exc_handler_1）では，まず，例外
ネストカウントをインクリメントする．CPU例外発生前がタスクコンテキストな
ら，非タスクコンテキスト用のスタックに切り換え，切り換え前のスタックポ
インタを切り換え後のスタック上に保存する．

----------------------------------------
		システム状態（コンテキストは除く）を，CPU例外発生時の状態にする
----------------------------------------

システム状態（コンテキストは除く）をCPU例外発生時の状態にするには，スー
パバイザモードに切り換え，IフラグとFフラグの状態をCPU例外発生時の状態に
戻す．

----------------------------------------
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
----------------------------------------

CPU例外ハンドラテーブル（exc_table）からCPU例外ハンドラの番地を取り出し，
CPU例外の情報を記憶している領域の先頭番地を第1パラメータ，CPU例外ハンド
ラ番号を第2パラメータとして呼び出す．第2パラメータにCPU例外ハンドラ番号
を渡すのは，default_exc_handlerで割込みハンドラ番号を表示できるようにす
るためで，ARMコア依存部の独自拡張である．

----------------------------------------
		if (CPU例外がタスクコンテキストで発生) {
			スタックをタスク用のスタックに戻し，
									タスクコンテキストに切り換える … (*k)
		}
		CPU例外処理からのリターン後に，CPU例外発生時のシステム状態に
													戻るように準備する
	}
	CPU例外が発生した状況を判断するための追加情報をスタック上から捨てる
	スクラッチレジスタをスタックから復帰する
	CPU例外処理からのリターン
}
----------------------------------------

例外ネストカウントをデクリメントし，0になった場合には，タスク用のスタッ
クに戻す．その後，CPU例外が発生した状況を判断するための追加情報をスタッ
ク上から捨て，スクラッチレジスタを復帰した後，例外からリターンする．

----------------------------------------
	else {
		if (CPU例外がタスクコンテキストで発生) {
----------------------------------------

カーネル管理のCPU例外の出入口処理では，まず，例外ネストカウントをインク
リメントする．CPU例外発生前が非タスクコンテキストなら，この後の{}内の処
理をスキップする（exc_handler_2に分岐）．

----------------------------------------
			少なくともカーネル管理の割込みを禁止した状態にする
----------------------------------------

ARMコアでは，例外の受付によりCPSRのIビットがセットされるため，この処理
は必要ない．

----------------------------------------
#ifdef TOPPERS_SUPPORT_OVRHDR
			ovrtimer_stop();			/* オーバランタイマの停止 */ … (*e)
#endif /* TOPPERS_SUPPORT_OVRHDR */
----------------------------------------

TOPPERS_SUPPORT_OVRHDRが定義されている場合には，ovrtimer_stopを呼び出
す．

----------------------------------------
			スタックを非タスクコンテキスト用のスタックに切り換え，
									非タスクコンテキストに切り換える
		}
----------------------------------------

スタックを非タスクコンテキスト用のスタックに切り換え，切り換え前のスタッ
クポインタを切り換え後のスタック上に保存する．これらの処理の後に，
exc_handler_2ラベルを置く．

----------------------------------------
		割込み優先度マスクを，CPU例外発生時の値に設定する … (*l)
----------------------------------------

チップ依存部のirc_begin_excを呼び出し，必要であれば，割込み優先度マスク
をCPU例外発生時の値に設定する．また，irc_end_excで必要な情報をスタック
に保存する．

----------------------------------------
		CPUロック解除状態にする（CPU例外発生時の割込み優先度マスクよりも
							優先度の高い割込みを受け付けるようにする）
----------------------------------------

割込みを許可して，CPUロック解除状態にする．

----------------------------------------
#ifdef LOG_EXC_ENTER
		log_exc_enter(CPU例外ハンドラ番号);
#endif /* LOG_EXC_ENTER */
----------------------------------------

LOG_EXC_ENTERが定義されている場合には，CPU例外ハンドラ番号をパラメータ
として，log_exc_enterを呼び出す．

----------------------------------------
		CPU例外ハンドラを，CPU例外の情報を記憶している領域の先頭番地を
									パラメータ（p_excinf）として呼び出す
----------------------------------------

CPU例外ハンドラテーブル（exc_table）からCPU例外ハンドラの番地を取り出し，
CPU例外の情報を記憶している領域の先頭番地を第1パラメータ，CPU例外ハンド
ラ番号を第2パラメータとして呼び出す．

----------------------------------------
#ifdef LOG_EXC_LEAVE
		log_exc_leave(CPU例外ハンドラ番号);
#endif /* LOG_EXC_LEAVE */

----------------------------------------

LOG_EXC_LEAVEが定義されている場合には，CPU例がハンドラ番号をパラメータ
として，log_exc_leaveを呼び出す．

----------------------------------------
		少なくともカーネル管理の割込みを禁止した状態にする … (*m)
----------------------------------------

カーネル管理の割込みを禁止するために，CPSR中のIビット（ただし，
TOPPERS_SAFEG_SECUREの場合は，Fビットも）をセットする．

----------------------------------------
		割込み優先度マスクを，CPU例外発生時の値に設定する … (*n)
----------------------------------------

チップ依存部のirc_end_excを呼び出し，割込み優先度マスクをCPU例外発生時
の値に設定する．

----------------------------------------
		if (CPU例外がタスクコンテキストで発生) {
----------------------------------------

例外ネストカウントをデクリメントする．デクリメント後の値が0でない場合
には，非タスクコンテキストでのCPU例外発生であるため，{}内の処理をスキッ
プする（exc_handler_5に分岐）．

----------------------------------------
			スタックをタスク用のスタックに戻し，タスクコンテキストに切り換える
																	… (*g)
----------------------------------------

タスクコンテキストのスタックポインタは，この時点で，スタックの先頭に保
存されているため，スタックの先頭を取り出して，スタックポインタに設定す
る．

----------------------------------------
			if (p_runtsk == NULL) {
----------------------------------------

p_runtskがNULLでなければ，この後の{}内の処理をスキップする
（exc_handler_3に分岐）．

----------------------------------------
				タスクのスタックに保存したスクラッチレジスタ等を捨てる … (*o)
----------------------------------------

ここでは，スタックに保存したスクラッチレジスタとCPU例外が発生した状況
を判断するための追加情報を捨てる．また，スタックポインタの調整を元に戻
すことも必要である．

----------------------------------------
				CPUロック状態にする … (*h)
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
				dispatcher_0に分岐する
			}
----------------------------------------

(*h)の処理は，irc_end_excを呼び出す前に行ったカーネル管理の割込みを禁
止する処理で十分であるため，ここでは行わない．(*i)については，
irc_end_excで割込み優先度マスクを割込み処理前の状態に戻すことで，満た
されているはずである．そこで，単にdispatcher_0に分岐すればよい．

----------------------------------------
			if (p_runtsk != p_schedtsk) {
----------------------------------------

この処理の前に，exc_handler_3ラベルを置く．p_runtskとp_schedtskが一致
する時は，exc_handler_4へ分岐する．

----------------------------------------
				CPUロック状態にする … (*h)
				割込み優先度マスクは，全解除状態（TIPM_ENAALL）になって
												いなければならない … (*i)
----------------------------------------

(*h)の処理は，irc_end_excを呼び出す前に行ったカーネル管理の割込みを禁
止する処理で十分であるため，ここでは行わない．(*i)については，
irc_end_excで割込み優先度マスクを割込み処理前の状態に戻すことで，満た
されているはずである．そこで，単にdispatcher_0に分岐すればよい．

----------------------------------------
				スクラッチレジスタを除くすべてのレジスタをスタックに保存する
				スタックポインタを自タスク（p_runtsk）のTCBに保存する
				ret_exc_rを，実行再開番地として自タスクのTCBに保存する … (*a)
				dispatcherに分岐する

			  ret_exc_r:
				スクラッチレジスタを除くすべてのレジスタをスタックから復帰する
			}
----------------------------------------

この辺りは素直に実装できる．

----------------------------------------
#ifdef TOPPERS_SUPPORT_OVRHDR
		ovrtimer_start();			/* オーバランタイマの動作開始 */
#endif /* TOPPERS_SUPPORT_OVRHDR */
----------------------------------------

この処理の前に，exc_handler_4のラベルを置く．TOPPERS_SUPPORT_OVRHDRが
定義されている場合には，ovrtimer_startを呼び出す．

----------------------------------------
		}
		CPU例外処理からのリターン後に，CPUロック解除状態に戻るように準備する
	}
	CPU例外が発生した状況を判断するための追加情報をスタック上から捨てる
	スクラッチレジスタをスタックから復帰する … (*p)
	CPU例外処理からのリターン
}
----------------------------------------

これらの処理の前に，exc_handler_5のラベルを置く．「CPU例外が発生した状
況を判断するための追加情報をスタック上から捨てる」以外の処理は，例外か
らの出口で行う．

●スタックポインタが不正の場合の対策

CPU例外ハンドラを実行する際に経由する部分で，CPU例外が起こる可能性とし
て，スタックポインタが不正な番地となった場合が考えられる．スーパバイザ
モードのスタックポインタが不正な番地となった状態で例外が発生すると，そ
の入口でスクラッチレジスタ等を保存しようとして，再度例外が発生する．こ
の状況で，例外発生が無限に繰り返すことを防ぐ対策をとることが望ましい．

これを防ぐために，データアボートの入口で，データアボートを発生させた番
地を調べ，CPU例外の入口であった場合には，フェイタルデータアボート処理
を行う．

フェイタルデータアボート処理では，スーパバイザモードのスタックを，強制
的に，非タスクコンテキスト用のスタックの初期値に設定し，例外ネストカウ
ントをインクリメントした後，CPU例外の処理を行う．この際，通常のデータ
アボートと区別できるように，EXCNO_FATALに対して登録されたCPU例外ハンド
ラを呼び出す．フェイタルデータアボートによるCPU例外処理からはリターン
してはならない（スタックを初期化しているので，何が起こるかわからない）．

○FPUのサポート

●FPUサポートの方針

ARMにおいては，FPUはオプションである．具体的には，Advanced SIMD拡張と
浮動小数点拡張がオプションになっている．これらのオプションを持つコアで
は，レジスタセットが拡張されており，タスク切換えや割込みハンドラ／CPU
例外ハンドラの出入口処理で保存／復帰が必要になる．以下では，FPUのため
に拡張されたレジスタを，FPUレジスタと呼ぶ．

FPUレジスタには，16本または32本の64ビットレジスタが含まれるため，すべ
てのタスク切換えと割込みハンドラ／CPU例外ハンドラの出入口処理で保存／
復帰を行うと，オーバヘッドが大きくなることに加えて，メモリ使用量も増加
する．

そこで，FPUを使用する処理を限定し（例えば，割込みハンドラではFPUを使用
しないなど），FPUレジスタの保存／復帰を行う場所が限定できるのが望まし
い．FPUを使用しない処理では，FPUをディスエーブルしておくことで，誤って
FPUを使用した場合を検出できるようにする（UNDEF例外が発生することで検出
できる）．

ここで，コンパイラによっては，ソース言語レベルで浮動小数点数（float型
やdouble型の数）を使用していないにも関わらず，FPU命令を生成する場合が
あることに注意が必要である．このようなコンパイラを使用する場合，FPUを
使用する処理を限定するには，コンパイルオプション等でFPUを使用しないよ
うにする必要がある．コンパイルオプションで制御する場合には，FPUを使用
する処理と使用しない処理を1つのソースファイルに入れないようにする必要
がある．

さらに，FPUを使用するオプションでコンパイルしたオブジェクトと，FPUを使
用しないオプションでコンパイルしたオブジェクトをリンクしようとすると，
エラーになる開発環境もある．このような開発環境では，FPUを使用する処理
を限定することは難しい．

以上より，FPUを使用する処理を限定する実装と，FPUを常に使用する実装を，
コンパイルスイッチで切り換えられるようにする方針とする．

●FPUレジスタの整理

アプリケーションレベルからアクセスできるFPUレジスタは，次の通り．

　＊16個の64ビットレジスタを持つ場合
	- S0～S31／D0～D15
		+ caller saved（スクラッチ）：D0～D7
		+ callee saved：D8～D15
		+ 保存／復帰は，D0～D15を使って行えばよい
	- FPSCR（Floating-point Status and Control Register）
		+ caller saved（スクラッチ）扱いとする

　＊32個の64ビットレジスタを持つ場合
	- S0～S31／D0～D31／Q0～Q15
		+ caller saved（スクラッチ）：D0～D7，D16～D31
		+ callee saved：D8～D15
		+ 保存／復帰は，D0～D31を使って行えばよい
	- FPSCR（Floating-point Status and Control Register）
		+ caller saved（スクラッチ）扱いとする

FPUのディスエーブルは，次のレジスタにより行う．このレジスタは，非特権
モード（PL0）からはアクセスできない．

	- FPEXC（Floating-Point Exception Control Register）
		+ FPEXC.EN：グローバルイネーブル
			0：Advanced SIMDと浮動小数点拡張をディスエーブル
			1：Advanced SIMDと浮動小数点拡張をイネーブル

また，FPUを使用する時には，次のレジスタでFPUをイネーブルしておく必要が
ある．このレジスタも，非特権モード（PL0）からはアクセスできない．

	- CPACR（Coprocessor Access Control Register）
		+ CP10とCP11のアクセス禁止／許可により，FPUを使用可能／使用不
		  可能にする

●FPUを常に使用する実装

FPUを常に使用する実装を用いる場合には，USE_ARM_FPU_ALWAYSをマクロ定義
することとする．また，サポートするFPUが32個の64ビットレジスタを持つ場
合には，USE_ARM_FPU_D32をマクロ定義することとする．

まず，スタートアップモジュールにおいて，外部の関数を呼び出す前に，FPU
を使用可能にする．具体的には，CPACRとFPEXCにより，FPUをイネーブルする．
スタートアップモジュールで行うのは，コンパイラがFPU命令を生成する可能
性があることを考慮したためである．

----------------------------------------
	/*
	 *  FPU（CP10とCP11）をアクセス可能に設定する．
	 *
	 *	CP15_READ_CPACR(reg);
	 *	reg |= (CP15_CPACR_CP10_FULLACCESS | CP15_CPACR_CP11_FULLACCESS);
	 *	CP15_WRITE_CPACR(reg);
	 */
	mrc		p15, 0, r0, c1, c0, 2
	orr		r0, r0, (CP15_CPACR_CP10_FULLACCESS | CP15_CPACR_CP11_FULLACCESS)
	mcr		p15, 0, r0, c1, c0, 2
	asm_inst_sync_barrier r0

	/*
	 *  FPUをイネーブルする．
	 *
	 *	set_fpexc(current_fpexc() | FPEXC_ENABLE);
	 */
	vmrs	r0, fpexc
	orr		r0, r0, #FPEXC_ENABLE
	vmsr	fpexc, r0
----------------------------------------

dispatchおよびdispatch_rに，FPUレジスタの保存／復帰を追加する．

----------------------------------------
ALABEL(dispatch)
	……
	push	{r4-r11}				/* 非スクラッチレジスタの保存 */
+	vpush	{d8-d15}				/* 非スクラッチFPUレジスタの保存 */
	ldr		r0, =p_runtsk			/* p_runtsk → r0 */
	ldr		r0, [r0]
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(dispatch_r)
+	vpop	{d8-d15}				/* 非スクラッチFPUレジスタの復帰 */
	pop		{r4-r11}				/* 非スクラッチレジスタの復帰 */
	……
----------------------------------------

割込みハンドラの出入口処理に，FPUレジスタの保存／復帰を追加する．

----------------------------------------
ALABEL(irq_handler)
	……
	/*
	 *  スタックポインタの調整
	 */
	and		r1, sp, #4
	sub		sp, sp, r1
+#ifdef USE_ARM_FPU_D32
+	vpush	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
+	vpush	{d0-d7}					/* スクラッチFPUレジスタの保存 */
+	vmrs	r0, fpscr
+	push	{r0,r1}					/* スタックポインタの調整値とFPSCRを保存 */
-	push	{r0,r1}					/* スタックポインタの調整値を保存 */
-									/* r0はスペース確保のため */
	……
----------------------------------------
ALABEL(irq_handler_2)
	……
	pop		{r0,r1}					/* スタックポインタの調整を元に戻す */
	add		sp, sp, r1
+#ifdef USE_ARM_FPU_D32
+ 	add		sp, sp, #232			/* スクラッチレジスタ等を捨てる */
+#endif /* USE_ARM_FPU_D32 */
+ 	add		sp, sp, #104			/* スクラッチレジスタ等を捨てる */
+#else /* USE_ARM_FPU_D32 */
-	add		sp, sp, #40				/* スクラッチレジスタ等を捨てる */
	b		dispatcher_0
	……
----------------------------------------
ALABEL(irq_handler_3)
	……
	push	{r6-r11}				/* 残りのレジスタの保存 */
+	vpush	{d8-d15}				/* 非スクラッチFPUレジスタの保存 */
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(ret_int_r)
+	vpop	{d8-d15}				/* 非スクラッチ全FPUレジスタの復帰 */
	pop		{r6-r11}				/* 残りのレジスタの復帰 */
	……
----------------------------------------
ALABEL(irq_handler_5)
	pop		{r0,r1}
+	vmsr	fpscr, r0				/* FPSCRを復帰 */
+	vpop	{d0-d7}					/* スクラッチFPUレジスタの復帰 */
+#ifdef USE_ARM_FPU_D32
+	vpop	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
	add		sp, sp, r1				/* スタックポインタの調整を元に戻す */
----------------------------------------

CPU例外ハンドラの出入口処理も，割込みハンドラと同様に変更する．

----------------------------------------
ALABEL(exc_handler_1)
	……
	/*
	 *  スタックポインタの調整
	 */
	and		r1, sp, #4
	sub		sp, sp, r1
+#ifdef USE_ARM_FPU_D32
+	vpush	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
+	vpush	{d0-d7}					/* スクラッチFPUレジスタの保存 */
+	vmrs	r0, fpscr
+	push	{r0,r1}					/* スタックポインタの調整値とFPSCRを保存 */
-	push	{r0,r1}					/* スタックポインタの調整値を保存 */
-									/* r0はスペース確保のため */
	……
----------------------------------------
ALABEL(exc_handler_2)
	……
	pop		{r0,r1}					/* スタックポインタの調整を元に戻す */
	add		sp, sp, r1
+#ifdef USE_ARM_FPU_D32
+	add		sp, sp, #240			/* スクラッチレジスタとCPU例外が発生した */
+#endif /* USE_ARM_FPU_D32 */		/*	状況を判断するための追加情報を捨てる */
+ 	add		sp, sp, #112
+#else /* USE_ARM_FPU_D32 */
-	add		sp, sp, #48				/* スクラッチレジスタとCPU例外が発生した */
	b		dispatcher_0			/*	状況を判断するための追加情報を捨てる */
	……
----------------------------------------
ALABEL(exc_handler_3)
	……
	push	{r6-r11}				/* 残りのレジスタの保存 */
+	vpush	{d8-d15}				/* 非スクラッチFPUレジスタの保存 */
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(ret_exc_r)
+	vpop	{d8-d15}				/* 非スクラッチ全FPUレジスタの復帰 */
	pop		{r6-r11}				/* 残りのレジスタの復帰 */
	……
----------------------------------------
ALABEL(exc_handler_5)
	pop		{r0,r1}
+	vmsr	fpscr, r0				/* FPSCRを復帰 */
+	vpop	{d0-d7}					/* スクラッチFPUレジスタの復帰 */
+#ifdef USE_ARM_FPU_D32
+	vpop	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
	add		sp, sp, r1				/* スタックポインタの調整を元に戻す */
	……
----------------------------------------

以上のコード修正は，USE_ARM_FPU_ALWAYSがマクロ定義されている場合のみ行
う．

●FPUを使用する処理を限定する実装

FPUを使用する処理を限定する方法について，タスクについては，ターゲット
定義のタスク属性として予約されているTA_FPUを活用し，TA_FPU属性のタスク
に対してのみFPUレジスタの保存／復帰を行う．TA_FPU属性でないタスクの実
行中は，誤ってFPU命令を実行しないように，FPUをディスエーブルする．

割込みハンドラ（タイムイベントハンドラを含む）とCPU例外ハンドラについ
ても，TA_FPU属性を設ける方法が考えられるが，これからのハンドラからFPU
を使用することはレアケースであると考えられるため，非タスクコンテキスト
ではFPUを使用できないものとする．ただし，ユーザのコードでFPUレジスタの
保存／復帰とFPUのイネーブルを行うことで，FPUを使用することは可能である．

FPUを使用する処理を限定する実装を用いる場合には，USE_ARM_FPU_SELECTIVE
をマクロ定義することとする．また，サポートするFPUが32個の64ビットレジ
スタを持つ場合には，USE_ARM_FPU_D32をマクロ定義することとする．

まず，スタートアップモジュールにおいて，CPACRによりFPUを使用可能にする．
また，FPEXCにより，FPUをディスエーブルしておく．これらの処理をスタート
アップモジュールで行う必然性はない（カーネルの初期化処理で行ってもよい）
が，FPUを常に使用する実装とあわせるために，スタートアップモジュールに
入れることにする．

----------------------------------------
	/*
	 *  FPU（CP10とCP11）をアクセス可能に設定する．
	 *
	 *	CP15_READ_CPACR(reg);
	 *	reg |= (CP15_CPACR_CP10_FULLACCESS | CP15_CPACR_CP11_FULLACCESS);
	 *	CP15_WRITE_CPACR(reg);
	 */
	mrc		p15, 0, r0, c1, c0, 2
	orr		r0, r0, (CP15_CPACR_CP10_FULLACCESS | CP15_CPACR_CP11_FULLACCESS)
	mcr		p15, 0, r0, c1, c0, 2
	asm_inst_sync_barrier r0

	/*
	 *  FPUをディスエーブルする．
	 *
	 *	set_fpexc(current_fpexc() & ~FPEXC_ENABLE);
	 */
	vmrs	r0, fpexc
	bic		r0, r0, #FPEXC_ENABLE
	vmsr	fpexc, r0
----------------------------------------

タスク切換えと割込みハンドラ／CPU例外ハンドラの出入口処理におけるFPUレ
ジスタの保存／復帰と，FPUのイネーブル／ディスエーブルには，いくつかの
アプローチが考えられる．

一長一短ではあるが，現在のコードでは，アプローチ3を採用している．なお，
以下のコード修正は，USE_ARM_FPU_SELECTIVEがマクロ定義されている場合の
み行う．

【アプローチ1】

FPUレジスタの保存／復帰を行うか否かの判定を，タスク属性のTA_FPUを参照
して行う方法．この方法を採ると，TA_FPU属性でないタスクに対しては，コン
テキストを保存するためのメモリ使用を増やさないように実装できる．一方，
保存／復帰を行うコードは長くなる．

タスク切換えにおけるFPUレジスタの保存／復帰と，FPUのイネーブル／ディス
エーブルのコードは次の通り．

----------------------------------------
ALABEL(dispatch)
	……
	push	{r4-r11}				/* 非スクラッチレジスタの保存 */
	ldr		r0, =p_runtsk			/* p_runtsk → r0 */
	ldr		r0, [r0]
+	ldr		r2, [r0,#TCB_p_tinib]	/* p_runtsk->p_tinib → r2 */
+	ldr		r1, [r2,#TINIB_tskatr]	/* p_runtsk->p_tinib->tskatr → r1 */
+	tst		r1, #TA_FPU
+	beq		1f
+	vpush	{d8-d15}				/* 非スクラッチFPUレジスタの保存 */
+1:
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(dispatch_r)
+	ldr		r2, [r4,#TCB_p_tinib]	/* p_runtsk->p_tinib → r2 */
+	ldr		r1, [r2,#TINIB_tskatr]	/* p_runtsk->p_tinib->tskatr → r1 */
+	tst		r1, #TA_FPU
+	vmrs	r0, fpexc
+	biceq	r0, r0, #FPEXC_ENABLE
+	orrne	r0, r0, #FPEXC_ENABLE
+	vmsr	fpexc, r0				/* FPEXCを設定 */
+	beq		1f
+	vpop	{d8-d15}				/* 非スクラッチFPUレジスタの復帰 */
+1:
	pop		{r4-r11}				/* 非スクラッチレジスタの復帰 */
	……
----------------------------------------
ALABEL(start_r)
	……
	ldr		r2, [r4,#TCB_p_tinib]	/* p_runtsk->p_tinib → r2 */
+	ldr		r1, [r2,#TINIB_tskatr]	/* p_runtsk->p_tinib->tskatr → r1 */
+	tst		r1, #TA_FPU
+	vmrs	r0, fpexc
+	biceq	r0, r0, #FPEXC_ENABLE
+	orrne	r0, r0, #FPEXC_ENABLE
+	vmsr	fpexc, r0				/* FPEXCを設定 */
	ldr		r0, [r2,#TINIB_exinf]	/* exinfをパラメータに */
	……
----------------------------------------

vpushne/vpopneを使用した方が効率的な部分があるが，コアの種類によっては，
FPUがディスエーブルの状態でvpushne/vpopneを実行するとUNDEF例外が発生す
るため，使用しないコードとしている．

割込みハンドラの出入口処理におけるFPUレジスタの保存／復帰と，FPUのイネー
ブル／ディスエーブルのコードは次の通り．

----------------------------------------
ALABEL(irq_handler_3)
	……
	push	{r6-r11}				/* 残りのレジスタの保存 */
+	ldr		r2, [r0,#TCB_p_tinib]	/* p_runtsk->p_tinib → r2 */
+	ldr		r1, [r2,#TINIB_tskatr]	/* p_runtsk->p_tinib->tskatr → r1 */
+	tst		r1, #TA_FPU
+	beq		1f						/* TA_FPU属性でない場合は分岐 */
+#ifdef USE_ARM_FPU_D32
+	vpush	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
+	vpush	{d0-d15}				/* 全FPUレジスタの保存 */
+	vmrs	r1, fpscr
+	push	{r1,r2}					/* FPSCRを保存 */
+1:									/* r2はアラインメントのため */
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(ret_int_r)
+	ldr		r2, [r4,#TCB_p_tinib]	/* p_runtsk->p_tinib → r2 */
+	ldr		r1, [r2,#TINIB_tskatr]	/* p_runtsk->p_tinib->tskatr → r1 */
+	tst		r1, #TA_FPU
+	vmrs	r0, fpexc
+	biceq	r0, r0, #FPEXC_ENABLE
+	orrne	r0, r0, #FPEXC_ENABLE
+	vmsr	fpexc, r0				/* FPEXCを設定 */
+	beq		1f						/* TA_FPU属性でない場合は分岐 */
+	pop		{r1,r2}
+	vmsr	fpscr, r1				/* FPSCRを復帰 */
+	vpop	{d0-d15}				/* 全FPUレジスタの復帰 */
+#ifdef USE_ARM_FPU_D32
+	vpop	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
+1:
	pop		{r6-r11}				/* 残りのレジスタの復帰 */
	……
----------------------------------------

さらに，割込みハンドラの出入口処理において，割込みハンドラの実行中に
FPUをディスエーブルし，実行が終わると元に戻すためのコードが必要である．
ここで，コンパイラがFPU命令を生成する可能性を考慮し，外部関数（オーバ
ランタイマの停止／動作開始など）を呼び出す時には，FPUをディスエーブル
しておくことが望ましい．

----------------------------------------
ALABEL(irq_handler)
	……
+	/*
+	 *  FPEXCを保存し，FPUをディスエーブルする．
+	 */
+	vmrs	r0, fpexc
+	str		r0, [sp]				/* FPEXCを保存 */
+	bic		r0, r0, #FPEXC_ENABLE
+	vmsr	fpexc, r0				/* FPEXCを設定 */
	
#ifdef TOPPERS_SUPPORT_OVRHDR
	/*
	 *  オーバランタイマを停止する．
	 */
	bl		ovrtimer_stop
#endif /* TOPPERS_SUPPORT_OVRHDR */
	……
----------------------------------------
ALABEL(irq_handler_4)
#ifdef TOPPERS_SUPPORT_OVRHDR
	/*
	 *  オーバランタイマを動作開始する．
	 */
	bl		ovrtimer_start
#endif /* TOPPERS_SUPPORT_OVRHDR */

+	/*
+	 *  FPUを元に戻す．
+	 *
+	 *  この処理は，タスク切換えを行わなかった場合にのみ必要である．タ
+	 *  スク切換えを行った場合には，コンテキストを復帰する処理でFPEXCを
+	 *  設定しているため，ここで再度行う必要はない．
+	 */
+	ldr		r0, [sp]				/* FPEXCを復帰 */
+	vmsr	fpexc, r0
	……
----------------------------------------

CPU例外ハンドラの出入口処理におけるFPUレジスタの保存／復帰と，FPUのイ
ネーブル／ディスエーブルのコードも，割込みハンドラと同様である．

上のコードでは，割込みハンドラ／CPU例外ハンドラの出口処理におけるオー
バランハンドラの動作開始を，FPUがイネーブルで，FPUレジスタに有効な値が
入っている状態で呼び出す場合がある．そのため，オーバランハンドラの動作
開始でFPUレジスタが使用されると，例外が発生せずに誤動作するため，注意
が必要である．これを防ぐには，ret_int_rでFPUレジスタを復帰した後にFPU
をディスエーブルすれば良いが，不要なオーバヘッドが生じるために実施して
いない．

このアプローチの1つの問題は，タスク以外の処理単位（割込みハンドラやCPU
例外ハンドラ）内のユーザコードで，FPUレジスタの保存／復帰とFPUのイネー
ブルを行うことでFPUを使用している場合に，その間に発生した割込み／CPU例
外の入口処理ではFPUをディスエーブルしないため，そこから呼ばれた割込み
ハンドラ／CPU例外ハンドラでFPUを使用すると，FPUレジスタの意図しない破
壊が起こってしまうことである．これを防止するには，非タスクコンテキスト
実行中に発生した割込み／CPU例外の入口処理でもFPUをディスエーブルすれば
良いが，不要なオーバヘッドが生じるために実施していない．

このアプローチのもう1つの問題は，割込みハンドラの出口でタスク切換えを
行う場合に，コンテキストを復帰する処理でFPEXCを設定した後に，再度，
FPEXCの値をスタックから復帰しているという無駄があることである（コード
中のコメントに記載してある）．

この無駄を防ぐには，irq_handler_4からFPUを元に戻すまでの処理を，タスク
切換えを行う場合と行わない場合で別々に持つ手が考えられるが，コードの総
量は増えてしまう．さらに，割込みハンドラの入口でFPEXCを保存するのをや
め，割込みハンドラの出口で，戻り先のタスクの属性に従ってFPEXCを設定す
る方法も考えられる．これにより，FPUを使用するタスクがない場合でも，割
込みハンドラの出入口処理で，FPEXCを保存するためのスタック使用量が増え
る（実際には，アラインメントのための空き領域をうまく活用している）とい
う欠点も解消することができる．

この方法を少し修正した方法として，dispatcherにおいては，必ずFPUをディ
スエーブルしておく方法が考えられる．ロジックが少しシンプルになるが，コー
ド総量は増えてしまうかもしれない．

【アプローチ2】

FPUレジスタの保存／復帰を行うか否かの判定を，FPEXCを参照して行う方法．
この方法を採ると，保存／復帰を行うかを判定するためのコードが簡潔に記述
できる（メモリ参照を行わないため，効率も良い）．また，FPEXCに設定する
値を作るコードも不要となる．一方，TA_FPU属性のタスクだけでなく，TA_FPU
属性でないタスクに対しても，FPEXCを保存するためにメモリ使用量が増えて
しまう．

タスク切換えにおけるFPUレジスタの保存／復帰と，FPUのイネーブル／ディス
エーブルのコードは次の通り．なお，start_rは，アプローチ1と同様である．

----------------------------------------
ALABEL(dispatch)
	……
	push	{r4-r11}				/* 非スクラッチレジスタの保存 */
	ldr		r0, =p_runtsk			/* p_runtsk → r0 */
	ldr		r0, [r0]
+	vmrs	r1, fpexc
+	tst		r1, #FPEXC_ENABLE
+	beq		1f
+	vpush	{d8-d15}				/* 非スクラッチFPUレジスタの保存 */
+1:
+	push	{r1,r2}					/* FPEXCを保存 */
+									/* r2はアラインメントのため */
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(dispatch_r)
+	pop		{r1,r2}					/* FPEXCを復帰 */
+	vmsr	fpexc, r1
+	tst		r1, #FPEXC_ENABLE
+	beq		1f
+	vpop	{d8-d15}				/* 非スクラッチFPUレジスタの復帰 */
+1:
	pop		{r4-r11}				/* 非スクラッチレジスタの復帰 */
	……
----------------------------------------

割込みハンドラの入口処理において，FPEXCを保存し，FPUをディスエーブルす
るためのコードは，アプローチ1と同じで良い．

タスク切換えにおいて，FPUがイネーブルかディスエーブルかを参照するため，
FPUを元に戻すコードは，タスク切換えの前に入れた方が少し無駄が減る（実
際には，タスク切換えを行う場合には，FPEXCを設定する命令は必要ない）．

----------------------------------------
ALABEL(irq_handler_3)
+#ifdef USE_ARM_FPU
+	/*
+	 *  FPUを元に戻す．
+	 */
+	ldr		r2, [sp]				/* FPEXCを復帰 */
+	vmsr	fpexc, r2
+#endif /* USE_ARM_FPU */

	ldr		r1, =p_schedtsk			/* p_schedtsk → r1 */
	ldr		r1, [r1]
	……
----------------------------------------

割込みハンドラの出入口処理におけるFPUレジスタの保存／復帰と，FPUのイネー
ブル／ディスエーブルのコードは次の通り．

----------------------------------------
ALABEL(irq_handler_3)
	……
	/*
	 * 【この時点のレジスタ状態】
	 *  r2：FPEXC
	 */
	push	{r6-r11}				/* 残りのレジスタの保存 */
+	tst		r2, #FPEXC_ENABLE
+	beq		1f
+#ifdef USE_ARM_FPU_D32
+	vpush	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
+	vpush	{d0-d15}				/* 全FPUレジスタの保存 */
+	vmrs	r1, fpscr
+1:
+	push	{r1,r2}					/* FPEXCとFPSCRを保存 */
	str		sp, [r0,#TCB_sp]		/* スタックポインタを保存 */
	……
----------------------------------------
ALABEL(ret_int_r)
+	pop		{r1,r2}
+	vmsr	fpexc, r2				/* FPEXCを復帰 */
+	tst		r2, #FPEXC_ENABLE
+	beq		1f
+	vmsr	fpscr, r1				/* FPSCRを復帰 */
+	vpop	{d0-d15}				/* 全FPUレジスタの復帰 */
+#ifdef USE_ARM_FPU_D32
+	vpop	{d16-d31}
+#endif /* USE_ARM_FPU_D32 */
+1:
	pop		{r6-r11}				/* 残りのレジスタの復帰 */
	……
----------------------------------------

上の割込みハンドラ／CPU例外ハンドラのタスク切換え処理には，FPEXCを二重
に保存するという無駄があるが，アラインメントのための空き領域に保存して
いるため，メモリの使用量は増えていない．

アプローチ1と同様に，割込みハンドラ／CPU例外ハンドラの出口処理における
オーバランハンドラの動作開始を，FPUがイネーブルで，FPUレジスタに有効な
値が入っている状態で呼び出す場合があるため，注意が必要である．

【アプローチ3】

アプローチ1とアプローチ2の折衷案も考えられる．具体的には，浮動小数点レ
ジスタの保存を行うか否かの判定を，FPEXCを参照して行い，浮動小数点レジ
スタの復帰を行うか否かの判定を，タスク属性のTA_FPUを参照して行う．

この方法は，TA_FPU属性でないタスクに対しては，コンテキストを保存するた
めのメモリ使用量を増やさないというアプローチ1の長所を継承し，保存を行
うコードを効率化しようというものである．ただし，復帰を行うコード（こち
らの方が長い）は効率化できない．言うまでもなく，処理方法に統一性がない
という気持ち悪さはある．

【他のアプローチ】

タスク切換え時に常にFPUレジスタを保存／復帰するのではなく，タスク切換
え後はFPUをディスエーブルしておき，FPU命令による例外が発生した時点で，
FPUレジスタの保存／復帰を行う方法（いわゆるlazy context switch）も考え
られるが，テスト的に実装・評価したところ，実行効率がむしろ低下したため，
採用していない．検討・実装した内容は，「TOPPERSプロジェクト 設計検討メ
モ ARM FPUの進んだサポート方法」にまとめてある．

●ABIを指定するコンパイルオプション（調査結果）

ABIを指定するコンパイルオプションは，次の3つがある．

	-mfloat-abi=soft		FPUを使用しない
	-mfloat-abi=softfp		FPUを使用し，FPUを使用しない場合と互換のコー
							リングコンベンションを用いる
	-mfloat-abi=hard		FPUを使用し，FPUを使用する場合に最適化され
							たコーリングコンベンションを用いる

コーリングコンベンションが異なるオブジェクトコードは，リンクできない．
すなわち，hardでコンパイルされたオブジェクトと，softfpでコンパイルされ
たオブジェクトは，リンクすることができない．softでコンパイルされたオブ
ジェクトと，softfpでコンパイルされたオブジェクトは，リンクすることがで
きる．

●コンパイルオプションによるFPU命令の生成（調査結果）

FPU命令が生成されるコンパイルオプションを調査した．調査には、以下のソー
スコードを用いた．

----------------------------------------
long long	x;
double		y;

unsigned int
test(void)
{
	x = 0;			/* 不動小数点数を使わないが，FPU命令が生成される */
	y += 1.0;
	asm volatile("vmrs r0, fpexc");
}
----------------------------------------

以下の内容は，次のコンパイラで調査した結果である．

	arm-none-eabi-gcc (GNU Arm Embedded Toolchain 9-2020-q2-update) 9.3.1 20200408 (release)

・FPU命令が生成されるオプション

	-mcpu=cortex-a9 -mfloat-abi=hard
	-mcpu=cortex-a9 -mfloat-abi=softfp
	-mcpu=cortex-a9 -mfpu=vfpv3-d16 -mfloat-abi=hard
	-mcpu=cortex-a9 -mfpu=vfpv3-d16 -mfloat-abi=softfp
	-mcpu=cortex-a9+nofp -mfpu=vfpv3-d16 -mfloat-abi=hard
	-mcpu=cortex-a9+nofp -mfpu=vfpv3-d16 -mfloat-abi=softfp

	-mcpu=mpcore -mfloat-abi=hard
	-mcpu=mpcore -mfloat-abi=softfp
	-mcpu=mpcore -mfpu=vfpv2 -mfloat-abi=hard
	-mcpu=mpcore -mfpu=vfpv2 -mfloat-abi=softfp
	-mcpu=mpcorenovfp -mfpu=vfpv2 -mfloat-abi=hard
	-mcpu=mpcorenovfp -mfpu=vfpv2 -mfloat-abi=softfp

・FPU命令が生成されないオプション（コンパイルは成功するが，アセンブラ
  でvmrs命令がエラーになる．浮動小数点演算は，ライブラリ呼出しになる）

	-mcpu=cortex-a9
	-mcpu=cortex-a9 -mfpu=vfpv3-d16
	-mcpu=cortex-a9+nofp
	-mcpu=cortex-a9+nofp -mfpu=vfpv3-d16
	-mcpu=cortex-a9+nofp -mfloat-abi=softfp ← エラーにならない

	-mcpu=mpcore
	-mcpu=mpcore -mfpu=vfpv2
	-mcpu=mpcorenovfp
	-mcpu=mpcorenovfp -mfpu=vfpv2
	-mcpu=mpcorenovfp -mfloat-abi=softfp ← エラーにならない

・コンパイルでエラーになるオプション

	-mcpu=cortex-a9+nofp -mfloat-abi=hard
	-mcpu=mpcorenovfp -mfloat-abi=hard

以上の調査結果より，-mcpuオプションでFPUを持たないプロセッサを指定
し，-mfpuオプションでFPUを指定すると，-mfpuオプションが優先され，FPUを
使うコードが生成されることがわかる．

●FPUを使用する処理を限定する場合のコンパイルオプション

FPUを使用する処理を限定する場合には，FPUを使用する処理単位を含むソース
ファイルはFPUを使用するオプションで，使用しない処理単位を含むソースファ
イルはFPUを使用しないオプションでコンパイルする必要がある．両者をリン
クするためには，ABIはsoftfpとする必要がある．

一般的な使い方として，カーネルを含む多くのソースファイルはFPUを使用せ
ず，一部のソースファイルだけでFPUを使用することが多いと思われる．そこ
で，以下のオプション設定を行うこととする．

・ターゲット依存部のMakefileでは，COPTSに，FPUを持たないプロセッサを指
  定する-mcpuオプションを設定する．

・アプリケーションのMakefileでは，FPUを使用するソースコードは，-mfpuオ
  プションを指定してコンパイルするように設定する．

なお，カーネルはFPUを使用しないオプションでコンパイルするが，そのよう
にした場合，FPUレジスタを保存／復帰するためにアセンブリ言語で記述され
たFPU命令がエラーとなる．そこで，FPU命令を使用するアセンブリ言語ソース
ファイルの先頭に以下の記述を入れ，ASM_ARM_FPU_TYPEをFPUの種類（例えば，
vfpv3）に定義することで，FPU命令がエラーにならないようにする．

----------------------------------------
	.fpu	ASM_ARM_FPU_TYPE
----------------------------------------

以上
